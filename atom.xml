<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>莱蒙黎梦</title>
  
  <subtitle>记录学习与思想</subtitle>
  <link href="http://www.lymone.cc/atom.xml" rel="self"/>
  
  <link href="http://www.lymone.cc/"/>
  <updated>2023-06-09T07:03:49.435Z</updated>
  <id>http://www.lymone.cc/</id>
  
  <author>
    <name>Lymone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中国矿业大学数据结构实践2</title>
    <link href="http://www.lymone.cc/p/2ce583c9.html"/>
    <id>http://www.lymone.cc/p/2ce583c9.html</id>
    <published>2023-06-09T06:19:25.000Z</published>
    <updated>2023-06-09T07:03:49.435Z</updated>
    
    <content type="html"><![CDATA[<p>如题，贴出AC代码，仅供参考不提供讲解</p><p>代码主打的就是一个叛逆</p><span id="more"></span><h1 id="问题-A-子串个数"><a href="#问题-A-子串个数" class="headerlink" title="问题 A: 子串个数"></a>问题 A: 子串个数</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你若干个字符串，请编程输出每个字符串的子串个数。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>若干个字符串，每个字符串占一行，字符串中不含空格，长度最大为1000。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对应每一行的字符串，输出该字符串子串的个数。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">apple</span><br><span class="line">software</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">16</span><br><span class="line">37</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s)&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    cout&lt;&lt;len*(len+<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘了空串是任何串的子串</p><h1 id="问题-B-模式串"><a href="#问题-B-模式串" class="headerlink" title="问题 B: 模式串"></a>问题 B: 模式串</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个目标串，请查找在给目标串中是否存在模式串，存在就输出第一个模式串在目标串中出现的位置。</p><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>占两行，第一行是目标串（长度小于1000），第二行为模式串（长度小于100）。</p><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>输出模式串在目标串中出现的位置，即模式串匹配到目标串时第一个字符在目标串的位置（注意从1开始描述字符开始位置），不能匹配时输出0.</p><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appleorange</span><br><span class="line">orange</span><br></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string pat;</span><br><span class="line">    <span class="type">int</span> *next;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KMP</span>(string _pat) &#123;</span><br><span class="line">        pat = _pat;</span><br><span class="line">        next = <span class="keyword">new</span> <span class="type">int</span>[pat.<span class="built_in">length</span>()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; pat.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pat[i] != pat[j])</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (pat[i] == pat[j])</span><br><span class="line">                j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; text.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text[i] != pat[j])</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (text[i] == pat[j])</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (j == pat.<span class="built_in">length</span>())</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">KMP</span>() &#123; <span class="keyword">delete</span>[] next; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    string pattern,text;</span><br><span class="line">    cin&gt;&gt;text&gt;&gt;pattern;</span><br><span class="line">    <span class="function">KMP <span class="title">kmp</span><span class="params">(pattern)</span></span>;</span><br><span class="line">    cout&lt;&lt;kmp.<span class="built_in">find</span>(text)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>谁家大好人数数从1开始数啊？啊？？</p><p>直接套的KMP模板，没啥好说的。</p><h1 id="问题-C-主对角线上的数据和"><a href="#问题-C-主对角线上的数据和" class="headerlink" title="问题 C: 主对角线上的数据和"></a>问题 C: 主对角线上的数据和</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个N行N列的方阵(或称N阶方阵)中，从左上角到右下角这一斜线上有N个数据元素，这个斜线称为方阵的主对角线。给你一个方阵，请求方阵主对角线上数据的和。</p><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>第一行是N（N&lt;100），表示下边是一个N阶方阵。接下来N行N列用空格间隔放置正整数（int型）。</p><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>N阶方阵主对角线上数据的和。</p><h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T,temp,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;T;j++)&#123;</span><br><span class="line">            cin&gt;&gt;temp;</span><br><span class="line">            <span class="keyword">if</span>(i==j)</span><br><span class="line">                ans+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-D-顺时针排螺旋阵"><a href="#问题-D-顺时针排螺旋阵" class="headerlink" title="问题 D: 顺时针排螺旋阵"></a>问题 D: 顺时针排螺旋阵</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个N行N列的方格矩阵，从外圈按顺时针依次填写自然数，这会构成一个螺旋阵，你能编程实现吗？<br>比如5行5列的情况如下：<br>1 2 3 4 5<br>16 17 18 19 6<br>15 24 25 20 7<br>14 23 22 21 8<br>13 12 11 10 9</p><h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>输入一个正整数数N（N&lt;100）。</p><h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>输出符合题意的螺旋阵。</p><h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br></pre></td></tr></table></figure><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> matrix[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ha=N/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ha;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=i,y=i;</span><br><span class="line">        <span class="type">int</span> step=N-i*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;step;j++)matrix[x++][y]=cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;step;j++)matrix[x][y++]=cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;step;j++)matrix[x--][y]=cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;step;j++)matrix[x][y--]=cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(N%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">        matrix[N/<span class="number">2</span>][N/<span class="number">2</span>]=N*N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="built_in">mm</span>(matrix);</span><br><span class="line">    <span class="built_in">init</span>(N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            cout&lt;&lt;matrix[j][i]&lt;&lt;(j==N<span class="number">-1</span>?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这题的代码还可以简单的缩短一下，这样重复性太高了，不过没啥意思</strong></p><h1 id="问题-E-汉诺塔游戏中的移动"><a href="#问题-E-汉诺塔游戏中的移动" class="headerlink" title="问题 E: 汉诺塔游戏中的移动"></a>问题 E: 汉诺塔游戏中的移动</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>有三根标为A,B,C的柱子，A柱子上从上到下按金字塔状依次叠放着n个半径从1厘米到n厘米的的圆盘，要把A上的所有盘子移动到柱子C上，中间可以临时放在B上，但每次移动每一根柱子上都不能出现大盘子在小盘子上方的情况，要求用最少的移动次数完成，请编程模拟每次移动。</p><h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>占一行，为整数n（n&lt;64），表示盘子数。</p><h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><p>把A上的所有盘子移动到柱子C上，每次只能移动一个盘子，输出移动每一次过程。每次移动占一行，第一个数表示第几步移动，第二个数是移动的盘子的半径，然后是从哪个柱子移动到哪个柱子。</p><h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 A-&gt;B</span><br><span class="line">2 2 A-&gt;C</span><br><span class="line">3 1 B-&gt;C</span><br></pre></td></tr></table></figure><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> A,<span class="type">char</span> B,<span class="type">char</span> C)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;++step&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;A&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;C&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">move</span>(n<span class="number">-1</span>,A,C,B);</span><br><span class="line">        cout&lt;&lt;++step&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;A&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>&lt;&lt;C&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">move</span>(n<span class="number">-1</span>,B,A,C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="built_in">move</span>(N,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题的关键就是要明白汉诺塔的递归解法，明白递归解法中各步骤的含义。</p><h1 id="问题-F-树的先根遍历"><a href="#问题-F-树的先根遍历" class="headerlink" title="问题 F: 树的先根遍历"></a>问题 F: 树的先根遍历</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>已知一颗树的节点间关系，请编程实现该树的先根遍历。</p><h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>若干行，每行描述了一组双亲节点和孩子节点的关系序偶对（每个节点用不同的大写字母表示，节点小于26个）。且树的度小于5。</p><h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>该树的先根遍历序列，序列中每个字母用空格隔开。</p><h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B E</span><br><span class="line">B F</span><br><span class="line">A B</span><br><span class="line">A C</span><br></pre></td></tr></table></figure><h4 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A B E F C</span><br></pre></td></tr></table></figure><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree[<span class="number">28</span>][<span class="number">28</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">char</span>(x+<span class="string">&#x27;A&#x27;</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[x][<span class="number">0</span>]==<span class="number">0</span>)   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tree[x][<span class="number">0</span>];i++)</span><br><span class="line">        <span class="built_in">func</span>(tree[x][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">mm</span>(tree);</span><br><span class="line">    <span class="type">char</span> A,B;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;A)&#123;</span><br><span class="line">        cin&gt;&gt;B;</span><br><span class="line">        tree[A-<span class="string">&#x27;A&#x27;</span>][++tree[A-<span class="string">&#x27;A&#x27;</span>][<span class="number">0</span>]]=B-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-G-树的后根遍历"><a href="#问题-G-树的后根遍历" class="headerlink" title="问题 G: 树的后根遍历"></a>问题 G: 树的后根遍历</h1><p><strong>内存限制：128 MB</strong></p><p>时间限制：1.000 S**</p><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>已知一颗树的节点间关系，请编程实现该树的后根遍历序列。</p><h4 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h4><p>若干行，每行描述了一组双亲节点和孩子节点的关系序偶对（每个节点用不同的大写字母表示，节点小于26个）。且树的度小于5。</p><h4 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h4><p>该树的后根遍历序列，序列中每个字母用空格隔开。</p><h4 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B E</span><br><span class="line">B F</span><br><span class="line">A B</span><br><span class="line">A C</span><br></pre></td></tr></table></figure><h4 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E F B C A</span><br></pre></td></tr></table></figure><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree[<span class="number">28</span>][<span class="number">28</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[x][<span class="number">0</span>]==<span class="number">0</span>)&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="built_in">char</span>(x+<span class="string">&#x27;A&#x27;</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tree[x][<span class="number">0</span>];i++)</span><br><span class="line">        <span class="built_in">func</span>(tree[x][i]);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">char</span>(x+<span class="string">&#x27;A&#x27;</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">mm</span>(tree);</span><br><span class="line">    <span class="type">char</span> A,B;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;A)&#123;</span><br><span class="line">        cin&gt;&gt;B;</span><br><span class="line">        tree[A-<span class="string">&#x27;A&#x27;</span>][++tree[A-<span class="string">&#x27;A&#x27;</span>][<span class="number">0</span>]]=B-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F、G题没有明确A作为根节点，不过经过观察确定A应该是根节点，尝试提交AC了，那就这样吧；同时因为题目特殊性，用矩阵的方式存储了树。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题，贴出AC代码，仅供参考不提供讲解&lt;/p&gt;
&lt;p&gt;代码主打的就是一个叛逆&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="题解" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="ACM" scheme="http://www.lymone.cc/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>中国矿业大学数据结构实践1</title>
    <link href="http://www.lymone.cc/p/b5ecd273.html"/>
    <id>http://www.lymone.cc/p/b5ecd273.html</id>
    <published>2023-06-02T09:30:23.000Z</published>
    <updated>2023-06-02T09:57:25.497Z</updated>
    
    <content type="html"><![CDATA[<p>如题，贴出AC代码，仅供参考不提供讲解</p><p>代码主打的就是一个叛逆</p><span id="more"></span><h1 id="问题-A-找新朋友"><a href="#问题-A-找新朋友" class="headerlink" title="问题 A: 找新朋友"></a>问题 A: 找新朋友</h1><p><strong>内存限制：32 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>新年快到了，天勤准备搞一个聚会，已经知道现有会员N人，把会员从1到N编号，其中会长的号码是N号，凡是和会长是老朋友的，那么该会员的号码肯定和N有大于1的公约数，否则都是新朋友，现在会长想知道究竟有几个新朋友？请你编程序帮会长计算出来。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行是测试数据的组数CN（Case number，1&lt;CN&lt;10000），接着有CN行正整数N（1&lt;n&lt;32768），表示会员人数。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>对于每一个N，输出一行新朋友的人数，这样共有CN行输出。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">25608</span><br><span class="line">24027</span><br></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7680</span><br><span class="line">16016</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">soluteA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> N;</span><br><span class="line">        cin&gt;&gt;N; </span><br><span class="line">        cout&lt;&lt;<span class="built_in">euler</span>(N)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">soluteA</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-B-互质"><a href="#问题-B-互质" class="headerlink" title="问题 B: 互质"></a>问题 B: 互质</h1><p><strong>内存限制：32 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个正整数n，请问有多少个比n小的且与n互质的正整数？<br>两个整数互质的意思是，这两个整数没有比1大的公约数。</p><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>输入包含多组测试数据。每组输入是一个正整数n（n&lt;=1000000000）。当n=0时，输入结束。</p><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>对于每组输入，输出比n小的且与n互质的正整数个数。</p><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">12</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">soluteB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">euler</span>(T)&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">soluteB</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-C-CPP2023-47-约瑟夫问题"><a href="#问题-C-CPP2023-47-约瑟夫问题" class="headerlink" title="问题 C: CPP2023-47-约瑟夫问题"></a>问题 C: CPP2023-47-约瑟夫问题</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>n个人围成一圈，按1到n的顺序编号。从第一个人开始报数（从1到m报数），凡报到m的人退出圈子，问最后留下的是原来的第几号。</p><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>首先输入两个正整数n和m，n表示n个人围一个圈子（n&gt;=2），m表示从1报数到m的人退出圈子（1=&lt;m）。</p><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>最后剩下的人的编号。</p><h4 id="样例输入-复制"><a href="#样例输入-复制" class="headerlink" title="样例输入 复制"></a>样例输入 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><h4 id="样例输出-复制"><a href="#样例输出-复制" class="headerlink" title="样例输出 复制"></a>样例输出 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? n : (<span class="built_in">f</span>(n - <span class="number">1</span>, m) + m - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n,m;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>(n,m)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-D-CPP2023-25-进制转换"><a href="#问题-D-CPP2023-25-进制转换" class="headerlink" title="问题 D: CPP2023-25-进制转换"></a>问题 D: CPP2023-25-进制转换</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>编写程序演示把一个10进制整数转换为R进制的转换结果。</p><h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>正整数N和R，空格分隔<br>N是输入的十进制数，R需要转换的进制数，2&lt;=R&lt;=20</p><h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>将10进制整数转换为R进制的转换结果，超过9的数字符号显示为A、B、C……Z等字母。</p><h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 16</span><br></pre></td></tr></table></figure><h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> num[<span class="number">37</span>] = <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, r;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; r;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(n % r);</span><br><span class="line">        n /= r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (st.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; num[st.<span class="built_in">top</span>()];</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-E-整数求和式的计算"><a href="#问题-E-整数求和式的计算" class="headerlink" title="问题 E: 整数求和式的计算"></a>问题 E: 整数求和式的计算</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个整数的求和式，比如1+2=，输出求和式和对应结果。请编程实现。</p><h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>一个求和式，形如a+b=。</p><h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><p>求和式及对应结果。</p><h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1+2=</span><br></pre></td></tr></table></figure><h4 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1+2=3</span><br></pre></td></tr></table></figure><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> x[<span class="number">200</span>];</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    cout&lt;&lt;x;</span><br><span class="line">    <span class="type">int</span> a,b,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x[i]!=<span class="string">&#x27;+&#x27;</span>)i++;</span><br><span class="line">    x[<span class="built_in">strlen</span>(x)<span class="number">-1</span>]=x[i]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(x,<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    cout&lt;&lt;a+b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-F-波兰表达式"><a href="#问题-F-波兰表达式" class="headerlink" title="问题 F: 波兰表达式"></a>问题 F: 波兰表达式</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) <em> 4的波兰表示法为</em> + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。</p><h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。</p><h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>输出为一行，表达式的值(保留6位小数)。</p><h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* + 11.0 12.0 + 24.0 35.0</span><br></pre></td></tr></table></figure><h4 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1357.000000</span><br></pre></td></tr></table></figure><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">calc</span> &#123;</span><br><span class="line">    <span class="type">bool</span> is_op;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">F</span> &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">double</span> num;</span><br><span class="line">    &#125; mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;calc&gt; vt;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">    calc m;</span><br><span class="line">    <span class="type">char</span> x[<span class="number">200</span>];</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x[<span class="number">0</span>] &gt; <span class="string">&#x27;9&#x27;</span> || x[<span class="number">0</span>] &lt; <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            m.is_op = <span class="literal">true</span>;</span><br><span class="line">            m.mem.op = x[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m.is_op = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">sscanf</span>(x, <span class="string">&quot;%lf&quot;</span>, &amp;a);</span><br><span class="line">            m.mem.num = a;</span><br><span class="line">        &#125;</span><br><span class="line">        vt.<span class="built_in">push_back</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = vt.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vt[i].is_op) &#123;</span><br><span class="line">            <span class="type">double</span> &amp;x = vt[i + <span class="number">2</span>].mem.num, &amp;y = vt[i + <span class="number">1</span>].mem.num;</span><br><span class="line">            <span class="keyword">switch</span> (vt[i].mem.op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                y += x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                y -= x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                y *= x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                y /= x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vt.<span class="built_in">erase</span>(vt.<span class="built_in">begin</span>() + i + <span class="number">2</span>);</span><br><span class="line">            vt.<span class="built_in">erase</span>(vt.<span class="built_in">begin</span>() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>, vt[<span class="number">0</span>].mem.num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问题-G-合并队列"><a href="#问题-G-合并队列" class="headerlink" title="问题 G: 合并队列"></a>问题 G: 合并队列</h1><p><strong>内存限制：128 MB</strong></p><p><strong>时间限制：1.000 S</strong></p><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>上体育课的时候，老师已经把班级同学排成了两个队列，而且每个队列都是按照从底到高排好队，现在需要把两个队列合并，合并后需要保证还是从低到高排列。合并队列，你能编程实现吗？</p><h4 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h4><p>第1行为n，表示开始排成的每个队列的长度。第2、3行是代表从小到大的n个整数，每行的整数间有一个空格间隔。</p><h4 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h4><p>输出占一行，为从小到大的整数，每个整数间间隔一个空格。</p><h4 id="样例输入-复制-1"><a href="#样例输入-复制-1" class="headerlink" title="样例输入 复制"></a>样例输入 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 3 5 8 15</span><br><span class="line">2 3 4 6 9</span><br></pre></td></tr></table></figure><h4 id="样例输出-复制-1"><a href="#样例输出-复制-1" class="headerlink" title="样例输出 复制"></a>样例输出 复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 3 4 5 6 8 9 15</span><br></pre></td></tr></table></figure><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">20000</span>],b[<span class="number">200000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;b[i];</span><br><span class="line">    <span class="type">int</span> pa=<span class="number">0</span>,pb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pa&lt;N&amp;&amp;pb&lt;N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[pa]&lt;b[pb])</span><br><span class="line">            cout&lt;&lt;a[pa++]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;b[pb++]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pa+pb!=<span class="number">2</span>*N)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa==N)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=pb;i&lt;N;i++)</span><br><span class="line">                cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=pa;i&lt;N;i++)</span><br><span class="line">                cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题，贴出AC代码，仅供参考不提供讲解&lt;/p&gt;
&lt;p&gt;代码主打的就是一个叛逆&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="算法" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="ACM" scheme="http://www.lymone.cc/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>KMP字符串模式匹配算法的两种实现</title>
    <link href="http://www.lymone.cc/p/5492a7c3.html"/>
    <id>http://www.lymone.cc/p/5492a7c3.html</id>
    <published>2023-05-31T04:10:47.000Z</published>
    <updated>2023-06-01T10:34:17.514Z</updated>
    
    <content type="html"><![CDATA[<p>暴力马拉车（BF）的时代结束了，来看看KMP算法吧，简单易用方便快捷！</p><span id="more"></span><h1 id="直接上码"><a href="#直接上码" class="headerlink" title="直接上码"></a>直接上码</h1><p>废话不多说，直接上代码</p><h2 id="1-动态规划-有限状态自动机"><a href="#1-动态规划-有限状态自动机" class="headerlink" title="1.动态规划|有限状态自动机"></a>1.动态规划|有限状态自动机</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string pat;</span><br><span class="line">    <span class="type">int</span> **dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KMP</span>(string _pat) &#123;</span><br><span class="line">        pat = _pat;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="type">int</span> *[pat.<span class="built_in">length</span>()];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">256</span>];</span><br><span class="line">        dp[<span class="number">0</span>][pat[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>,j = <span class="number">1</span>; j &lt; pat.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">            dp[j] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">256</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">                dp[j][i] = i == pat[j] ? j + <span class="number">1</span> : dp[x][i];</span><br><span class="line">            x = dp[x][pat[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            j = dp[j][text[i]];</span><br><span class="line">            <span class="keyword">if</span> (j == pat.<span class="built_in">length</span>())</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">KMP</span>() &#123;</span><br><span class="line">        <span class="type">int</span> x = pat.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span> (x--)</span><br><span class="line">            <span class="keyword">delete</span>[] dp[x];</span><br><span class="line">        <span class="keyword">delete</span>[] dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-动态规划-空间最优"><a href="#2-动态规划-空间最优" class="headerlink" title="2.动态规划|空间最优"></a>2.动态规划|空间最优</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string pat;</span><br><span class="line">    <span class="type">int</span> *next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KMP</span>(string _pat) &#123;</span><br><span class="line">        pat = _pat;</span><br><span class="line">        next = <span class="keyword">new</span> <span class="type">int</span>[pat.<span class="built_in">length</span>()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; pat.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pat[i] != pat[j])</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">next[i] = pat[i] == pat[j] ? ++j : j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; text.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text[i] != pat[j])</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (text[i] == pat[j])</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (j == pat.<span class="built_in">length</span>())</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">KMP</span>() &#123; <span class="keyword">delete</span>[] next; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h1><p>两段代码都非常的容易理解：</p><p>代码1是正向思考，枚举在字符串匹配中可能遇到的所有情况，将这些情况的状态变化记录成DP数组，在查找的时候直接无脑代入DP数组就好了，代码看起来繁复的部分基本是由于开二维数组造成的。</p><p>代码2是递推思考，思考如果在匹配<code>pattern[n]</code>的时候如果匹配不上就往前推进到前一个前缀字符串相同的位置，直到匹配成功或者彻底失败，然后重新匹配。</p><p>很明显，代码1是空间换时间的做法，如果需要匹配的对象有明确的范围的话（例如为ASCII范围内）且需要匹配的<code>pattern</code>串长度合适或者需要多次使用，代码1明显更合适。</p><p>而代码2中规中矩，基本是KMP最基本的思路，相对可用范围也更宽泛一些，但是在面对重复多次的恶意数据仍然有超时风险。</p><p>结论就是：DP党无脑冲1，CPC日常写2（2的码量更小）</p><h1 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h1><p>想要看懂KMP，最关键的是要能明白KMP为什么能这么干，也就是KMP的理论依据：</p><blockquote><p>如果text[a:b]匹配pattern[c:d]</p><p>那么显然对于pattern[c:d]中的任何pattern[x:d]都有text[y:b]与之对应</p><p>如果存在pattern[c:z]与pattern[x:d]相同</p><p>那么显然text[y:b]与pattern[c:z]匹配</p></blockquote><p>推理过程如上，稍作理解一下即可，简单来说就是如果已知两段字符串匹配，那么<strong>更短相同前缀</strong>的模式字符串显然也在同一个位置完全匹配。</p><p>如果<code>pattern[j]</code>与当前的<code>text[i]</code>并不匹配，那我们就可以尝试去查询<code>pattern</code>中出现的<strong>更短相同前缀</strong>的位置，来寻找是否有可以匹配的字符，这样就可以规避大量无意义的繁复“马拉车”。</p><p>这也是KMP算法的精髓所在——头可断血可流，字符串绝对不回推。</p><p>为了更好的<del>装逼</del>解释这个过程，我们引入动态规划<code>状态</code>的概念，对于一个长度为$N$的pattern串，认为这个串并不是线性的，而是有$N$个状态分立，处理每个状态时在不同的情况下可能转向不同的状态。</p><p>显然当pattern转为第$N+1$个状态时，发生了完整的匹配。</p><p>既然如此，状态在不同情况下的转移条件就成为了关键，那么状态转移的条件是什么呢？</p><p>代码1和代码2选择了不同的方法描述这个条件：</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><p>代码1选择开辟了一个二维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[pat.<span class="built_in">length</span>()][<span class="number">256</span>];</span><br></pre></td></tr></table></figure><p>这个数组的功能也很明显，对于每个状态<code>dp[i]</code>记录当这个状态遇见字符’c’时的转移路径<code>dp[i][c]</code></p><p>核心代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必要时需要对dp数组进行初始化</span></span><br><span class="line"><span class="comment">//初始化：当且仅当状态0遇到pat[0]时发生转移到状态1</span></span><br><span class="line">dp[<span class="number">0</span>][pat[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//开辟一个变量作为影子状态指针，影子状态存在的原因解释在下文</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历pattern字符串，从1开始</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; pat.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">    <span class="comment">//遍历ASCII全集情况下的状态转移方式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        <span class="comment">//显然当i==pat[j]时转移到顺序下一状态即j+1</span></span><br><span class="line">        <span class="comment">//当i!=pat[j]时，dp[j][i]取决于影子位置遇到i时的转移方式</span></span><br><span class="line">dp[j][i] = i == pat[j] ? j + <span class="number">1</span> : dp[x][i];</span><br><span class="line">    <span class="comment">//跟进影子状态，将遇到当前字符时影子状态的转移赋给影子状态即影子状态跟进一位</span></span><br><span class="line">x = dp[x][pat[j]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解这个代码的核心在于理解影子状态的存在。</p><p>每个状态<code>i</code>，在遇到<code>pat[i]</code>的时候转移到顺序状态很好理解，但是其他的情况如何转移呢？</p><p>最朴素的思路就是从x=[0:i]依次查找[x:i]是否存在一个最长的字符串与pattern串从0开始完全匹配——等等，匹配？！我们不是正在写用于匹配计算的状态转移数组嘛！</p><p>我们是从位置1开始遍历，刚刚好位置0的转移已经写好了，那么如果我们在推进遍历的过程中持续将当前<code>pat[i]</code>输入状态转移数组，维护一个从位置0开始匹配的X，那么显然X的位置就是最长的<strong>更短相同前缀</strong>字符串的位置。任意位置<code>i</code>在遇到任何<code>c!=pat[i]</code>的时候的处理方式，可以完全参照i状态的影子状态<code>X</code>的处理方式——既然i状态遇到C无法更进一步到顺序下一个位置，那么就尽可能的前往pattern串中更偏后的位置。</p><p>转移数组会在推进的过程中越来越复杂，显然的对于几个具有相同短前缀的位置，后一个位置会通过X继承前一个位置的全部转移方式。</p><p>使用这种方法生成dp数组后，在进行查找的时候只需要无脑放心的顺序将text串的每一个字符塞进转移数组就好了，每次判断一下是否抵达完全匹配的状态即可。</p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>代码2记录转移路径的方法是开辟了一个一维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> next[pat.<span class="built_in">length</span>()];</span><br></pre></td></tr></table></figure><p>核心代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next[i]中记录的是状态i+1最近的相同前缀的状态的位置</span></span><br><span class="line"><span class="comment">//如果不能理解第一行这句话可以先看下文</span></span><br><span class="line"><span class="comment">//如此如果状态0匹配失败下一次仍然匹配状态0，同时也应该注意到需要对状态0进行特判</span></span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//开辟一个变量记录影子状态j</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历pattern字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pat.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">//如果影子状态j与当前状态i字符不相同，则j转移到上一个有相同前缀的位置进行尝试</span></span><br><span class="line">    <span class="comment">//显然这种特殊的记录方式数学本质使然，加之状态0的特殊情况，显然不能查找状态0的上一状态</span></span><br><span class="line">    <span class="comment">//所以需要在这里对j=0进行特判，此处j&gt;0替换为j!=0不会发生任何错误</span></span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pat[i] != pat[j])</span><br><span class="line">        <span class="comment">//如果pat[j]匹配失败，显然pat[0:j-1]已经完全匹配成功，那么显然pat[0:next[j-1]]已经匹配</span></span><br><span class="line">        <span class="comment">//因此可以通过j = next[j - 1]转移到相同前缀字符串待匹配的位置</span></span><br><span class="line">j = next[j - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//退出while循环有两种可能，如果是因为pat[i] == pat[j]退出，</span></span><br><span class="line">    <span class="comment">//那么显然pat[0:j]与pat[x:i]完全匹配-》j+1状态是i+1状态最近的相同前缀状态</span></span><br><span class="line">    <span class="comment">//按照next[]记录规则将++j赋给next[],同时维护了影子状态</span></span><br><span class="line">    <span class="comment">//如果是因为j=0退出那么显然在i状态之前已经没有更短相同前缀状态，此时给next[i]赋j皆可</span></span><br><span class="line">next[i] = pat[i] == pat[j] ? ++j : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>临时兴起改的减缩版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=next[<span class="number">0</span>]=<span class="number">0</span>;i&lt;pat.<span class="built_in">length</span>();next[i++]=pat[i]==pat[j]?++j:j)</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;pat[i]!=pat[j])j=next[j<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><p>因为对于任何一个状态i只需要考虑前一个更短相同前缀的状态在哪里，原理倒是很好理解，递归查找嘛。</p><p>这段代码不好理解的地方主要就是因为太精炼，next数组的意义太绕了。</p><p><code>next[i-1]</code>记录的是如果状态i匹配失败下一步<strong>需要匹配</strong>的状态!如果能理解这一点那么这段代码就能完全理解了！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;暴力马拉车（BF）的时代结束了，来看看KMP算法吧，简单易用方便快捷！&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="算法" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="ACM" scheme="http://www.lymone.cc/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>生活·美学·摄影|大师作品欣赏</title>
    <link href="http://www.lymone.cc/p/sheying.html"/>
    <id>http://www.lymone.cc/p/sheying.html</id>
    <published>2023-05-30T10:12:58.260Z</published>
    <updated>2023-06-06T10:31:58.810Z</updated>
    
    <content type="html"><![CDATA[<p>想要学习摄影，首先要做的就是能够欣赏摄影！</p><p>我在这里摘录一些我比较喜欢的大师作品/获奖作品，记录一下我对这些作品理解。</p><p>同时这篇博文也算作是<code>生活·美学·摄影</code>课程的结课作业罢。</p><span id="more"></span><h1 id="一些作品"><a href="#一些作品" class="headerlink" title="一些作品"></a>一些作品</h1><p>在美的欣赏这方面，我一直认为自己是个俗人，能深刻的打动我的，往往是来自大自然的最真实的震撼。</p><p>我最喜欢的一类摄影作品，也大都是对于自然景色的抓拍，其中往往有着极具特色的光影画面。</p><h2 id="《Rainbow-over-the-African-Plain》"><a href="#《Rainbow-over-the-African-Plain》" class="headerlink" title="《Rainbow over the African Plain》"></a>《Rainbow over the African Plain》</h2><p><strong>摄影：吴芷芬（中国香港）</strong></p><p><img src="https://pic4.zhimg.com/80/v2-534b13543ffa1d2d7d946ca994a6afcb_1440w.webp" alt="《Rainbow over the African Plain》 摄影：吴芷芬（中国香港）"></p><p>这个作品是<code>雷克雅未克站ICE优异证书</code>获奖作品。</p><p>《非洲平原上空的彩虹》画面主体是一抹十分清晰的彩虹，彩虹两端分别连接了天空中刚刚散去的乌云和明亮的草原。这个作品最能打动我的其实是草原的光影效果——我最喜欢的<code>阴天的光</code>，草原看似阴暗细看却十分的明亮，有种奇葩的美。画面中出现的极多的对比效果：阴暗的天空和明亮的草原、枯黄的草与油绿的树、即将拥挤繁闹的草原和即将空荡的天空，带来了极强的视觉冲击。</p><p>摄影师吴芷芬（中国香港），我能获得的关于她的信息并不很多，但是我找到了她其他的获奖作品：</p><p><img src="https://p4.itc.cn/q_70/images03/20230308/0c6b2ac3ff044659805ee60dc54525a6.jpeg" alt="img"></p><h3 id="《Mountain-Guards》"><a href="#《Mountain-Guards》" class="headerlink" title="《Mountain Guards》"></a>《Mountain Guards》</h3><p>“RefleX”国际艺术摄影展（黑山）光影大师MOL银牌（旅游组）</p><p><img src="https://s1.ax1x.com/2023/06/06/pCim9b9.jpg" alt="img"></p><h3 id="《Llama-in-Front-of-The-Horn》"><a href="#《Llama-in-Front-of-The-Horn》" class="headerlink" title="《Llama in Front of The Horn》"></a><strong>《Llama in Front of The Horn》</strong></h3><p>2022聚焦国际四地巡回摄影展（印度）组委会金牌</p><p>2022第二十七届SCPS国际摄影展（新加坡）新加坡彩色摄影学会SCPS铜牌</p><p><img src="https://s1.ax1x.com/2023/06/06/pCimPER.jpg" alt="img"></p><h3 id="《Travel-Through-Colourful-Mountain》"><a href="#《Travel-Through-Colourful-Mountain》" class="headerlink" title="《Travel Through Colourful Mountain》"></a><strong>《Travel Through Colourful Mountain》</strong></h3><p>2022斯里兰卡“SIELEDIBA”三地巡回摄影奖（斯里兰卡）俱乐部CLUB金牌</p><p>2022第二十七届SCPS国际摄影展（新加坡）新加坡彩色摄影学会SCPS金牌</p><p><img src="https://s1.ax1x.com/2023/06/06/pCimiU1.jpg" alt="img"></p><h3 id="《Rain-And-Mist》"><a href="#《Rain-And-Mist》" class="headerlink" title="《Rain And Mist》"></a><strong>《Rain And Mist》</strong></h3><p>2022淡马锡国际摄影沙龙四地巡回赛（新加坡）APU金牌</p><hr><p>可以看出来吴芷芬女士也对自然奇观情有独钟，不过她并不长于使用光影对比来表现画面，这几幅获奖作品无不展现出了自然的瑰丽景色，不过这并不是我最喜欢的作品类型。</p><h2 id="《Symmetry》"><a href="#《Symmetry》" class="headerlink" title="《Symmetry》"></a>《Symmetry》</h2><p>500px ID： Amarate Tansawet</p><p><img src="https://pic3.zhimg.com/80/v2-2a2b95e2d567efb73d1d515fcc7ef1ba_1440w.webp" alt="img"></p><p>国际摄影大赛专业组-自然类日出获奖作品。</p><p><strong>Amarate Tansawet</strong>的作品就属于我最喜欢的那一类，他也非常喜欢拍摄亮色的云层，瑰丽的自然景色，画面中表现的往往是对视觉神经最原始的震撼。</p><p>《Symmetry》中的主体是一片平静明亮的湖面，恰逢此时日出云里烧火，山色半遮，给人一种<code>神仙居处恰在此，天庭景色更几时</code>的感觉。</p><p>最巧妙的就是，画面中的云、湖、屋、树皆不可或缺，这些独立的景色皆对天空异色形成映衬，逆光下的阴影与天空的光形成了一个完整的整体。</p><p><strong>Amarate Tansawet</strong>是一位来自泰国的摄影师，他运营着自己的媒体<strong>Gift of Light</strong> ，在媒体中他是这样介绍自己的<code>An award-winning semi-pro landscape photographer &amp; FEISOL pro photographer.</code>好吧有够谦虚的，我愿称之为最专业的风景摄影师之一。</p><p>Amarate Tansawet的作品还能找到许多：</p><p><img src="http://i1.wp.com/mmbiz.qpic.cn/mmbiz_jpg/MMJfKRcfBvMuq7MevMynLxj2ahEUfibpicQK0fciaIia1cBhXYRia9357gEyNT0U7MSp8U4ShQ8S8npWR5icWR58ehVA/0?wx_fmt=jpeg" alt="img"></p><h3 id="《世外桃源》"><a href="#《世外桃源》" class="headerlink" title="《世外桃源》"></a>《世外桃源》</h3><blockquote><p>拍攝日期：2015年12月8日<br>拍攝地點：紐西蘭西岸大區的Waikowhai<br>相機型號：SONY ILCE-7RM2<br>焦距：70 mm<br>快門速度：1/60 sec<br>光圈：f/8<br>ISO感光度：100</p></blockquote><p>拍摄于纽西兰国家公园马瑟森湖，同样的光影对比，暖红到冷蓝形成了最壮丽的对比。</p><p>这张图找不到高清图源了，不过自然光影带给你我的原始震撼仍然清晰可感。</p><p><img src="https://s1.ax1x.com/2023/05/30/p9jj0C4.jpg" alt="p9jj0C4.jpg"></p><p>画面被近处的枯木和远处的美景对半占据，远处盖山雪顶映照着夕阳余晖，此景又反射在水面上。</p><p>陆地上的三处景起伏有致，安排合理，主体突出，有种呼之欲出的感觉。</p><p>美，实在是美！妙，实在是妙！</p><p><img src="https://s1.ax1x.com/2023/06/06/pCimJxS.jpg" alt="img"></p><p>在戈壁地貌以仰视的视角拍摄银河，占据主体的风化岩构成了一个坚实的三角形，坚实稳固，似通天际，与天空中的银河化为一体，奇！</p><p><img src="https://s1.ax1x.com/2023/06/06/pCimG28.jpg" alt="img"></p><p>这张应该是人物摄影，但是对焦却不在人物上，广角镜头的效果将画面展示的淋漓尽致。</p><p>地平线边的太阳恰好出现在人的脚下，真实的记录了来自大自然的震撼。</p><h3 id="GoL作品一组"><a href="#GoL作品一组" class="headerlink" title="GoL作品一组"></a>GoL作品一组</h3><p>上传在<code>Gift of Light</code>上的19 Aug…World Photography Day参赛作品。</p><p><a href="https://imgse.com/i/p9jvNQA"><img src="https://s1.ax1x.com/2023/05/30/p9jvNQA.jpg" alt="p9jvNQA.jpg"></a></p><h3 id="《Frozen-Hideout》"><a href="#《Frozen-Hideout》" class="headerlink" title="《Frozen Hideout》"></a>《Frozen Hideout》</h3><blockquote><p>Sony Alpha a7 II<br>Sony Vario-Tessar T* FE 16-35mm f/4 ZA OSS<br>16mm<br>ƒ/19<br>1/15s<br>ISO 100</p></blockquote><p><a href="https://imgse.com/i/p9jvqyR"><img src="https://s1.ax1x.com/2023/05/30/p9jvqyR.jpg" alt="p9jvqyR.jpg"></a></p><h3 id="《Magic-Moment》"><a href="#《Magic-Moment》" class="headerlink" title="《Magic Moment》"></a>《Magic Moment》</h3><blockquote><p>Sony Alpha a7R II<br>Sony FE 70-200mm f/4 G OSS<br>70mm<br>ƒ/8.0<br>1/1000s<br>ISO 100</p></blockquote><p>可以看得出来Amarate Tansawet真的是非常擅长于借助环境营造光效，尤其擅长于记录光影效果、记录大自然营造的奇景，他的作品总是能带给观者一种来自生物本能的最原始的震撼。作品中常常使用广角镜头来将更多的内容纳入画中，也增添了震撼感。</p><h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><p>我想，所谓摄影，应当是记录为主。摄影时选择一个恰当的角度无可厚非，但是有人会去专门营造一个景观，或者专门挑选一个对象，为他安排一个人造的环境，我觉得这就不是摄影了，这只是通过拍摄这一手法来完成了一个他心目中的作品。</p><p>你我这一生，已经去过了很多地方，也将要去许多地方，已经过了许多时间，也将要过许多时间，无论如何我们都会看过很多风景也将要看到更多的风景，我学习摄影的初心就是想要在看到一个让我震撼到无以复加的场景的时候，有能力在电子的幅框里将它完完本本的记录下来，将它分享给本没有机会见识到的人，这才是摄影。</p><p>在我看来Amarate Tansawet真的实现了摄影的内涵，他这里并没有非常明显卖弄技巧，但是巧妙的设计了非常的出众画面结构，他已经将摄影的技巧完美的融入到了作品中去，技巧手法与对象不再是独立的两部分。他眼前看到的光景成功的记录到了一份十几兆的文件中，让本没有机会看到的我感受到最原始的震撼，这就是完美的摄影作品。</p><p>我多次提到了最原始的震撼，其实我只是想将这种感受与一般的“美”或者“震撼”区分开来，我觉得美感是天生的也有培养的，但人对美的感受终究是天生的，这种感受是来自于自然的，不受社会或者舆论的牵制，它可能是“丑”的，但却终究是符合“最原始的震撼”，我不知道这样能不能描述我的美学价值观。</p><p>用一句话结尾吧：<strong>生活</strong>，<strong>美学</strong>，<strong>摄影</strong>！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;想要学习摄影，首先要做的就是能够欣赏摄影！&lt;/p&gt;
&lt;p&gt;我在这里摘录一些我比较喜欢的大师作品/获奖作品，记录一下我对这些作品理解。&lt;/p&gt;
&lt;p&gt;同时这篇博文也算作是&lt;code&gt;生活·美学·摄影&lt;/code&gt;课程的结课作业罢。&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://www.lymone.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="摄影" scheme="http://www.lymone.cc/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>博客恢复</title>
    <link href="http://www.lymone.cc/p/83ff057a.html"/>
    <id>http://www.lymone.cc/p/83ff057a.html</id>
    <published>2023-04-03T12:44:26.000Z</published>
    <updated>2023-04-03T13:15:45.097Z</updated>
    
    <content type="html"><![CDATA[<p>博客终于恢复了</p><span id="more"></span><p>众所周知，这个简陋的、访问速度奇慢的、内容极少的、原创内容稀缺的、蒟蒻的博客，是使用<code>hexo</code>框架搭建的，并且部署在<code>GitHub Page</code>上。</p><p>有一天我突发奇想要将源码也上传到<code>GitHub</code>上，说干就干，于是我的账户名下多了一个仓库。</p><p>However, 在上传的过程中，<code>GitHub</code>检测到我的博客中使用的<code>Hexo-Next</code>主题在<code>GitHub</code>有单独的仓库，于是用了一个指向原仓库的链接代替了我的文件。</p><p>我当时并不知道这件事，我以为他会保留我更改的部分，然而并不是……于是悲剧就发生了。</p><p>在这个学期开学的时候，我并没有把最新的博客文件传输到我的笔记本电脑上，而是使用pull更新了我笔记本电脑上的文件。</p><p>当我再次决定发一篇博文的时候，突然发现！主题文件！是！旧版的！</p><p>是的，我在假期里更新了侧栏、文章底部还有关于访问人数的部分，同时还有用hash缩短<code>url</code>以及Latex公式的渲染，其中有一半的功能全靠修改主题文件实现。</p><p>呜呼~</p><p>今天联系家里人帮我打开电脑电源，成功把文件传输过来了（好耶）</p><p>就酱~</p><p>恢复更新~</p><p>PS: WOL(Wake On Lan)配置的再好也顶不过断电啊</p><p>PPS: 闲的没事的时候给电脑配置好远程连接还是很必要的（确信</p><p>PPPS: 路由器御三家用的那个免费DDNS真的很容易掉，如果想要稳定使用，最好让路由器定时重启</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;博客终于恢复了&lt;/p&gt;</summary>
    
    
    
    <category term="开始" scheme="http://www.lymone.cc/categories/%E5%BC%80%E5%A7%8B/"/>
    
    
    <category term="EasyX" scheme="http://www.lymone.cc/tags/EasyX/"/>
    
    <category term="GitHub" scheme="http://www.lymone.cc/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>从列车调度学习STL集合Set</title>
    <link href="http://www.lymone.cc/p/24d1d7dd.html"/>
    <id>http://www.lymone.cc/p/24d1d7dd.html</id>
    <published>2023-04-02T10:20:00.000Z</published>
    <updated>2023-04-03T13:02:35.676Z</updated>
    
    <content type="html"><![CDATA[<p><strong>7-10 列车调度</strong></p><p>分数 25</p><p>火车站的列车调度铁轨的结构如下图所示。</p><span id="more"></span><p><img src="https://images.ptausercontent.com/188" alt="img"></p><p>两端分别是一条入口（Entrance）轨道和一条出口（Exit）轨道，它们之间有<code>N</code>条平行的轨道。每趟列车从入口可以选择任意一条轨道进入，最后从出口离开。在图中有9趟列车，在入口处按照{8，4，2，5，3，9，1，6，7}的顺序排队等待进入。如果要求它们必须按序号递减的顺序从出口离开，则至少需要多少条平行铁轨用于调度？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个整数<code>N</code> (2 ≤ <code>N</code> ≤105)，下一行给出从1到<code>N</code>的整数序号的一个重排列。数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出可以将输入的列车按序号递减的顺序调离所需要的最少的铁轨条数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">8 4 2 5 3 9 1 6 7</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>代码长度限制</p><p>16 KB</p><p>时间限制</p><p>300 ms</p><p>内存限制</p><p>64 MB</p><hr><p>这题思维量不大，火车在调度站的排列和蜘蛛纸牌类似，每一列必须维持大序号的列车在前面。如果新一列车对于所有的调度铁轨尾车号要大，就新开一个铁轨。</p><p>很容易发现，即使是最下面的是N号车厢，或者连续的N到N-M号车厢，并不会影响调度铁轨的数量。所以无需考虑。同时还很容易发现，新插入的列车如果小于多列调度铁轨尾车序号，应该选择与其序号相差最小的调度铁轨。</p><p>我最开始的思路是维护一个数组和一个size变量，分别存储每列车的最后一辆车的序号和调度铁轨的最小数量，但是在插入的过程中需要遍历所有的轨道进行比较，时间复杂度过高最终导致超时。</p><p>再进一步，我考虑到了sort排序进行维护，没有实现</p><p>最终采用的方法是维护一个set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mm(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N, temp;</span><br><span class="line">    cin &gt;&gt; N;N--;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    cin&gt;&gt; temp;</span><br><span class="line">    s.<span class="built_in">insert</span>(temp);</span><br><span class="line">    <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(temp &lt; *s.<span class="built_in">rbegin</span>())&#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">upper_bound</span>(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set会内部会自动维护一个红黑树，相对更高效，只需比较新插入的列车和set的尾部量（最大量<code>rbegin()</code>）的比较，如果更大就插入新值，如果已经有更大的量，就删除一个最小的比新插入的量大的量<code>upper_bound()</code>然后插入目前的列车（实际就是模拟了最新的列车替代了之前的列车）。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>引用<a href="https://wyqz.top/p/870124582.html">C++ STL总结 | 行码棋 (wyqz.top)</a></p><h2 id="7-set"><a href="#7-set" class="headerlink" title="7 set"></a>7 set</h2><h3 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h3><p>set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。</p><p>即：set里面的元素<strong>不重复 且有序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br></pre></td></tr></table></figure><p>Cpp</p><h3 id="7-2-函数方法"><a href="#7-2-函数方法" class="headerlink" title="7.2 函数方法"></a>7.2 函数方法</h3><div class="table-container"><table><thead><tr><th style="text-align:left">代码</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>s.begin()</code></td><td style="text-align:left">返回set容器的第一个元素的地址（迭代器）O(1)�(1)</td></tr><tr><td style="text-align:left"><code>s.end()</code></td><td style="text-align:left">返回set容器的最后一个元素的下一个地址（迭代器）O(1)�(1)</td></tr><tr><td style="text-align:left"><code>s.rbegin()</code></td><td style="text-align:left">返回逆序迭代器，指向容器元素最后一个位置O(1)�(1)</td></tr><tr><td style="text-align:left"><code>s.rend()</code></td><td style="text-align:left">返回逆序迭代器，指向容器第一个元素前面的位置O(1)�(1)</td></tr><tr><td style="text-align:left"><code>s.clear()</code></td><td style="text-align:left">删除set容器中的所有的元素,返回unsigned int类型O(N)�(�)</td></tr><tr><td style="text-align:left"><code>s.empty()</code></td><td style="text-align:left">判断set容器是否为空O(1)�(1)</td></tr><tr><td style="text-align:left"><code>s.insert()</code></td><td style="text-align:left">插入一个元素</td></tr><tr><td style="text-align:left"><code>s.size()</code></td><td style="text-align:left">返回当前set容器中的元素个数O(1)�(1)</td></tr><tr><td style="text-align:left"><code>erase(iterator)</code></td><td style="text-align:left">删除定位器iterator指向的值</td></tr><tr><td style="text-align:left"><code>erase(first,second）</code></td><td style="text-align:left">删除定位器first和second之间的值</td></tr><tr><td style="text-align:left"><code>erase(key_value)</code></td><td style="text-align:left">删除键值key_value的值</td></tr><tr><td style="text-align:left">查找</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>s.find(element)</code></td><td style="text-align:left">查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td></tr><tr><td style="text-align:left"><code>s.count(element)</code></td><td style="text-align:left">查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现</td></tr><tr><td style="text-align:left"><code>s.lower_bound(k)</code></td><td style="text-align:left">返回大于等于k的第一个元素的迭代器O(logN)�(����)</td></tr><tr><td style="text-align:left"><code>s.upper_bound(k)</code></td><td style="text-align:left">返回大于k的第一个元素的迭代器O(logN)�(����)</td></tr></tbody></table></div><hr><h3 id="7-3-访问"><a href="#7-3-访问" class="headerlink" title="7.3 访问"></a>7.3 访问</h3><p><strong>迭代器访问</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>智能指针</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>访问最后一个元素</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">cout &lt;&lt; *s.<span class="built_in">rbegin</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//第二种</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator iter = s.<span class="built_in">end</span>();</span><br><span class="line">iter--;</span><br><span class="line">cout &lt;&lt; (*iter) &lt;&lt; endl; <span class="comment">//打印2;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种</span></span><br><span class="line">cout &lt;&lt; *(--s.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><hr><h3 id="7-4-重载-lt-运算符"><a href="#7-4-重载-lt-运算符" class="headerlink" title="7.4 重载&lt;运算符"></a>7.4 重载&lt;运算符</h3><ul><li><strong>基础数据类型</strong></li></ul><p>方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1; <span class="comment">// 默认从小到大排序</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt; &gt; s2; <span class="comment">// 从大到小排序</span></span><br></pre></td></tr></table></figure><p>方式二：重载运算符。（很麻烦，不太常用，没必要）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载 &lt; 运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; u, <span class="type">const</span> <span class="type">int</span>&amp; v)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">// return + 返回条件</span></span><br><span class="line">       <span class="keyword">return</span> u &gt; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>, cmp&gt; s; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    s.<span class="built_in">insert</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">// 10 9 8 7 6 5 4 3 2 1</span></span><br></pre></td></tr></table></figure><p>方式三：初始化时使用匿名函数定义比较规则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; <span class="built_in">s</span>([&amp;](<span class="type">int</span> i, <span class="type">int</span> j)&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j; <span class="comment">// 从大到小</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    s.<span class="built_in">insert</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>高级数据类型（结构体）</strong></li></ul><p>直接重载结构体运算符即可，让结构体可以比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;p) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大</span></span><br><span class="line">        <span class="keyword">if</span>(x == p.x)</span><br><span class="line">            <span class="keyword">return</span> y &lt; p.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; p.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;Point&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">/* 输入</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">    cout &lt;&lt; i.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="7-5-其它set"><a href="#7-5-其它set" class="headerlink" title="7.5 其它set"></a>7.5 其它set</h3><p><code>multiset</code>:元素可以重复，且元素有序<br><code>unordered_set</code> ：元素无序且只能出现一次<br><code>unordered_multiset</code> ： 元素无序可以出现多次</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;7-10 列车调度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分数 25&lt;/p&gt;
&lt;p&gt;火车站的列车调度铁轨的结构如下图所示。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://www.lymone.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="ACM" scheme="http://www.lymone.cc/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Html5+CSS前端开发学习</title>
    <link href="http://www.lymone.cc/p/8942eb80.html"/>
    <id>http://www.lymone.cc/p/8942eb80.html</id>
    <published>2023-04-02T10:20:00.000Z</published>
    <updated>2023-04-03T13:02:47.325Z</updated>
    
    <content type="html"><![CDATA[<p>中国林业大学-web前端开发<code>mooc</code>笔记</p><span id="more"></span><h2 id="1-2-网站与网页"><a href="#1-2-网站与网页" class="headerlink" title="1-2 网站与网页"></a>1-2 网站与网页</h2><p>网站(Website)是指网页(Webpage)的合集</p><p>主页一般称为index</p><p>关键的网页元素：</p><p>logo站标</p><p>导航栏</p><p>超文本链接</p><p>banner横幅（一般作为广告</p><p>表单（填写的内容，例如登录账号</p><p>网站-&gt;文件夹（网页-&gt;文件）-（放置于）-&gt;服务器端</p><p>浏览器：解析网页源代码，渲染网页</p><h2 id="1-3web前端开发的技术构成和技术标准"><a href="#1-3web前端开发的技术构成和技术标准" class="headerlink" title="1-3web前端开发的技术构成和技术标准"></a>1-3web前端开发的技术构成和技术标准</h2><p>结构：HTML//从语义角度，描述页面结构</p><p>样式：CSS//从审美角度，美化页面</p><p>行为：JavaScript//从交互的角度，提升用户体验</p><p>w3c组织负责技术标准制定</p><p>官方网站www.w3.org</p><p>官方学习网站www.w3school.com.cn</p><h1 id="2-HTML"><a href="#2-HTML" class="headerlink" title="2.HTML"></a>2.HTML</h1><h2 id="2-1HTML概述"><a href="#2-1HTML概述" class="headerlink" title="2.1HTML概述"></a>2.1HTML概述</h2><p>HTML是超文本标记语言</p><p>以标签作为基本单位，不区分大小写</p><p>开始标签结束标签成对出现<code>&lt;a&gt;&lt;/a&gt;</code></p><p>单独出现的标签尾部自带一个<code>\</code>例如<code>&lt;aaa\&gt;</code></p><p>标签、属性：</p><p><code>&lt;img src=&quot;&quot; alt=&quot;&quot;\&gt;</code></p><p>标签 属性 属性 其间以空格隔开，一个标签可以带有多个属性</p><h2 id="2-2HTML文件结构"><a href="#2-2HTML文件结构" class="headerlink" title="2.2HTML文件结构"></a>2.2HTML文件结构</h2><h3 id="html文件的基本结构"><a href="#html文件的基本结构" class="headerlink" title="html文件的基本结构"></a>html文件的基本结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>//标题</span><br><span class="line">        //头部内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">//主体内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="html5标准文件基本结构"><a href="#html5标准文件基本结构" class="headerlink" title="html5标准文件基本结构"></a>html5标准文件基本结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>//文档类型：符合html5标准</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>//搜索引擎属性 en zh</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>//元数据 指出字符集编码方式</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>//标题</span><br><span class="line">        //头部内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">//主体内容</span><br><span class="line">    //实际展示的内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式:"></a>编码方式:</h3><p>ASCII</p><p>GB2312 简体中文</p><p>Unicode 万国码</p><p>UTF-8</p><h2 id="2-3-HTML标签"><a href="#2-3-HTML标签" class="headerlink" title="2-3 HTML标签"></a>2-3 HTML标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span>换行</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;url:/&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span>创建水平线</span><br><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="HTML-提示：使用小写属性"><a href="#HTML-提示：使用小写属性" class="headerlink" title="HTML 提示：使用小写属性"></a>HTML 提示：使用小写属性</h4><p>属性和属性值对大小写<em>不敏感</em>。</p><p>不过，万维网联盟在其 HTML 4 推荐标准中推荐小写的属性/属性值。</p><p>而新版本的 (X)HTML 要求使用小写属性。</p><h4 id="始终为属性值加引号"><a href="#始终为属性值加引号" class="headerlink" title="始终为属性值加引号"></a>始终为属性值加引号</h4><p>属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。</p><p>在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=&#x27;Bill &quot;HelloWorld&quot; Gates&#x27;</span><br></pre></td></tr></table></figure><h4 id="下面列出了适用于大多数-HTML-元素的属性："><a href="#下面列出了适用于大多数-HTML-元素的属性：" class="headerlink" title="下面列出了适用于大多数 HTML 元素的属性："></a>下面列出了适用于大多数 HTML 元素的属性：</h4><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">class</td><td style="text-align:left"><em>classname</em></td><td style="text-align:left">规定元素的类名（classname）</td></tr><tr><td style="text-align:left">id</td><td style="text-align:left"><em>id</em></td><td style="text-align:left">规定元素的唯一 id</td></tr><tr><td style="text-align:left">style</td><td style="text-align:left"><em>style_definition</em></td><td style="text-align:left">规定元素的行内样式（inline style）</td></tr><tr><td style="text-align:left">title</td><td style="text-align:left"><em>text</em></td><td style="text-align:left">规定元素的额外信息（可在工具提示中显示）</td></tr></tbody></table></div><h4 id="不建议使用（已经被样式替代）的标签-属性："><a href="#不建议使用（已经被样式替代）的标签-属性：" class="headerlink" title="不建议使用（已经被样式替代）的标签/属性："></a>不建议使用（已经被样式替代）的标签/属性：</h4><div class="table-container"><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><center></td><td style="text-align:left">定义居中的内容。</td></tr><tr><td style="text-align:left"><font> 和 <basefont></td><td style="text-align:left">定义 HTML 字体。</td></tr><tr><td style="text-align:left"><s> 和 <strike></td><td style="text-align:left">定义删除线文本</td></tr><tr><td style="text-align:left"><u></td><td style="text-align:left">定义下划线文本</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">align</td><td style="text-align:left">定义文本的对齐方式</td></tr><tr><td style="text-align:left">bgcolor</td><td style="text-align:left">定义背景颜色</td></tr><tr><td style="text-align:left">color</td><td style="text-align:left">定义文本颜色</td></tr></tbody></table></div><h4 id="Style属性实例"><a href="#Style属性实例" class="headerlink" title="Style属性实例"></a>Style属性实例</h4><h5 id="HTML-样式实例-背景颜色"><a href="#HTML-样式实例-背景颜色" class="headerlink" title="HTML 样式实例 - 背景颜色"></a>HTML 样式实例 - 背景颜色</h5><p>background-color 属性为元素定义了背景颜色：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;background-color:yellow&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&quot;background-color:red&quot;</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;background-color:green&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="HTML-样式实例-字体、颜色和尺寸"><a href="#HTML-样式实例-字体、颜色和尺寸" class="headerlink" title="HTML 样式实例 - 字体、颜色和尺寸"></a>HTML 样式实例 - 字体、颜色和尺寸</h5><p>font-family、color 以及 font-size 属性分别定义元素中文本的字体系列、颜色和字体尺寸：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;font-family:verdana&quot;</span>&gt;</span>A heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-family:arial;color:red;font-size:20px;&quot;</span>&gt;</span>A paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="HTML-样式实例-文本对齐"><a href="#HTML-样式实例-文本对齐" class="headerlink" title="HTML 样式实例 - 文本对齐"></a>HTML 样式实例 - 文本对齐</h5><p>text-align 属性规定了元素中文本的水平对齐方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center&quot;</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The heading above is aligned to the center of this page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h3><blockquote><p>以下元素都是短语元素。虽然这些标签定义的文本大多会呈现出特殊的样式，但实际上，这些标签都拥有确切的语义。</p><p>我们并不反对使用它们，但是如果您只是为了达到某种视觉效果而使用这些标签的话，我们建议您使用样式表，那么做会达到更加丰富的效果。</p></blockquote><h4 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h4><div class="table-container"><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;b&gt;</code></td><td style="text-align:left">定义粗体文本。</td></tr><tr><td style="text-align:left"><code>&lt;big&gt;</code></td><td style="text-align:left">定义大号字。</td></tr><tr><td style="text-align:left"><code>&lt;em&gt;</code></td><td style="text-align:left">定义着重文字。</td></tr><tr><td style="text-align:left"><code>&lt;i&gt;</code></td><td style="text-align:left">定义斜体字。</td></tr><tr><td style="text-align:left"><code>&lt;small&gt;</code></td><td style="text-align:left">定义小号字。</td></tr><tr><td style="text-align:left"><code>&lt;strong&gt;</code></td><td style="text-align:left">定义加重语气。</td></tr><tr><td style="text-align:left"><code>&lt;sub&gt;</code></td><td style="text-align:left">定义下标字。</td></tr><tr><td style="text-align:left"><code>&lt;sup&gt;</code></td><td style="text-align:left">定义上标字。</td></tr><tr><td style="text-align:left"><code>&lt;ins&gt;</code></td><td style="text-align:left">定义插入字。</td></tr><tr><td style="text-align:left"><code>&lt;del&gt;</code></td><td style="text-align:left">定义删除字。</td></tr></tbody></table></div><h4 id="“计算机输出”标签"><a href="#“计算机输出”标签" class="headerlink" title="“计算机输出”标签"></a>“计算机输出”标签</h4><div class="table-container"><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;code&gt;</code></td><td style="text-align:left">定义计算机代码。</td></tr><tr><td style="text-align:left"><code>&lt;kbd&gt;</code></td><td style="text-align:left">定义键盘码。</td></tr><tr><td style="text-align:left"><code>&lt;samp&gt;</code></td><td style="text-align:left">定义计算机代码样本。</td></tr><tr><td style="text-align:left"><code>&lt;tt&gt;</code></td><td style="text-align:left">定义打字机代码。</td></tr><tr><td style="text-align:left"><code>&lt;var&gt;</code></td><td style="text-align:left">定义变量。</td></tr><tr><td style="text-align:left"><code>&lt;pre&gt;</code></td><td style="text-align:left">定义预格式文本。</td></tr></tbody></table></div><h4 id="HTML-引文、引用和定义元素"><a href="#HTML-引文、引用和定义元素" class="headerlink" title="HTML 引文、引用和定义元素"></a>HTML 引文、引用和定义元素</h4><div class="table-container"><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><abbr></td><td style="text-align:left">定义缩写或首字母缩略语。</td></tr><tr><td style="text-align:left"><address></td><td style="text-align:left">定义文档作者或拥有者的联系信息。</td></tr><tr><td style="text-align:left"><bdo></td><td style="text-align:left">定义文本方向。</td></tr><tr><td style="text-align:left"><blockquote></td><td style="text-align:left">定义从其他来源引用的节。</td></tr><tr><td style="text-align:left"><dfn></td><td style="text-align:left">定义项目或缩略词的定义。</td></tr><tr><td style="text-align:left"><q></td><td style="text-align:left">定义短的行内引用。</td></tr><tr><td style="text-align:left"><cite></td><td style="text-align:left">定义著作的标题。</td></tr></tbody></table></div><p>颜色，颜色使用十六进制RGB #66CCFF</p><h3 id="HTML-css样式表"><a href="#HTML-css样式表" class="headerlink" title="HTML css样式表"></a>HTML css样式表</h3><h4 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h4><p>当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h4><p>当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 <style> 标签定义内部样式表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>: red&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>当特殊的样式需要应用到个别元素时，就可以使用内联样式。使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red; margin-left: 20px&quot;</span>&gt;</span></span><br><span class="line">This is a paragraph</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML链接"><a href="#HTML链接" class="headerlink" title="HTML链接"></a>HTML链接</h3><h4 id="HTML-超链接（链接）"><a href="#HTML-超链接（链接）" class="headerlink" title="HTML 超链接（链接）"></a>HTML 超链接（链接）</h4><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</p><p>当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。</p><p>我们通过使用 <a> 标签在 HTML 中创建链接。</p><p>有两种使用 <a> 标签的方式：</p><ol><li>通过使用 href 属性 - 创建指向另一个文档的链接</li><li>通过使用 name 属性 - 创建文档内的书签</li></ol><h4 id="HTML-链接-target-属性"><a href="#HTML-链接-target-属性" class="headerlink" title="HTML 链接 - target 属性"></a>HTML 链接 - target 属性</h4><p>使用 Target 属性，你可以定义被链接的文档在何处显示。</p><p>下面的这行会在新窗口打开文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.w3school.com.cn/&quot; target=&quot;_blank&quot;&gt;Visit W3School!&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="HTML-链接-name-属性"><a href="#HTML-链接-name-属性" class="headerlink" title="HTML 链接 - name 属性"></a>HTML 链接 - name 属性</h4><p>name 属性规定锚（anchor）的名称。</p><p>您可以使用 name 属性创建 HTML 页面中的书签。</p><p>书签不会以任何特殊方式显示，它对读者是不可见的。</p><p>当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。</p><h5 id="命名锚的语法："><a href="#命名锚的语法：" class="headerlink" title="命名锚的语法："></a>命名锚的语法：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;label&quot;&gt;锚（显示在页面上的文本）&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong>锚的名称可以是任何你喜欢的名字。</p><p><strong>提示：</strong>您可以使用 id 属性来替代 name 属性，命名锚同样有效。</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;tips&quot;&gt;基本的注意事项 - 有用的提示&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>然后，我们在同一个文档中创建指向该锚的链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#tips&quot;&gt;有用的提示&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>您也可以在其他页面中创建指向该锚的链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.w3school.com.cn/html/html_links.asp#tips&quot;&gt;有用的提示&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将 # 符号和锚名称添加到 URL 的末端，就可以直接链接到 tips 这个命名锚了。</p><h3 id="HTML图像"><a href="#HTML图像" class="headerlink" title="HTML图像"></a>HTML图像</h3><h4 id="图像标签（-lt-img-gt-）和源属性（Src）"><a href="#图像标签（-lt-img-gt-）和源属性（Src）" class="headerlink" title="图像标签（&lt;img&gt;）和源属性（Src）"></a>图像标签（<code>&lt;img&gt;</code>）和源属性（Src）</h4><p>在 HTML 中，图像由 <code>&lt;img&gt;</code> 标签定义。</p><p><code>&lt;img&gt;</code> 是<strong>空标签</strong>，意思是说，它只包含属性，并且没有闭合标签。</p><p>要在页面上显示图像，你需要使用源属性（src）。src 指 “source”。源属性的值是图像的 URL 地址。</p><p>定义图像的语法是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="替换文本属性（Alt）"><a href="#替换文本属性（Alt）" class="headerlink" title="替换文本属性（Alt）"></a>替换文本属性（Alt）</h4><p>alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;boat.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Big Boat&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;中国林业大学-web前端开发&lt;code&gt;mooc&lt;/code&gt;笔记&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="前端" scheme="http://www.lymone.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="HTML" scheme="http://www.lymone.cc/tags/HTML/"/>
    
    <category term="CSS" scheme="http://www.lymone.cc/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Tokitsukaze and Energy Tree谈变量大小与时间复杂度</title>
    <link href="http://www.lymone.cc/p/bf5a535.html"/>
    <id>http://www.lymone.cc/p/bf5a535.html</id>
    <published>2023-01-18T12:10:25.000Z</published>
    <updated>2023-03-03T13:04:08.332Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/contest/46810/D">https://ac.nowcoder.com/acm/contest/46810/D</a><br>来源：牛客网</p><p>Tokitsukaze 有 nnn 个节点的有根能量树，根为 111。最开始，树上每个节点的能量都是 000。</p><span id="more"></span><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Tokitsukaze 有 $n$ 个节点的有根能量树，根为 $1$。最开始，树上每个节点的能量都是 $0$。 </p><p> 现在 Tokitsukaze 有 $n$ 个能量球，第 $i$ 个能量球拥有 $v_i$ 能量。她想把这 $n$ 个能量球分别放置在能量树的每个节点上，使能量树的每个节点都恰好有一个能量球。</p><p> Tokitsukaze 每次只能放置一个能量球，所以她将进行 $n$ 次操作。每一次操作，她会选择一个能量球，再选择一个没有能量球的能量树节点 $x$，把刚刚选择的能量球放置在节点 $x$ 上。在这之后，Tokitsukaze 能获得以 $x$ 为根的子树中的所有能量球的能量 (包括节点 $x$ 的能量球能量)。</p><p> 在放置完所有能量球后，Tokitsukaze 可能获得的总能量最多是多少？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><p>第一行包含一个整数 $n (1≤n≤2⋅10^5)$。</p><p>第二行包含 $n-1$ 个整数 $f_2,f_3,…,f_n (1≤f_i≤i−1)$，表示节点 $i$ 的父亲是 $f_i$。</p><p>第三行包含 $n$ 个整数 $v_1,v_2,…,v_n (1≤v_i≤10^5)$，分别表示能量球的能量。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><p>输出一个整数，表示 Tokitsukaze 可能获得的最多总能量。              </p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><blockquote><p>5<br>1 1 3 3<br>1 1 2 2 3</p></blockquote><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote><p>22</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> dt[<span class="number">200010</span>], mul[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, temp;</span><br><span class="line">    ll all = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    mul[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        mul[i] = mul[temp] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; dt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(dt + <span class="number">1</span>, dt + n + <span class="number">1</span>, <span class="built_in">greater</span>&lt;ll&gt;());</span><br><span class="line">    <span class="built_in">sort</span>(mul + <span class="number">1</span>, mul + n + <span class="number">1</span>, <span class="built_in">greater</span>&lt;ll&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        all += <span class="built_in">ll</span>(mul[i]) * dt[i]; <span class="comment">// 2e5*1e5&gt;2e10</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; all &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><h2 id="故事从26行开始"><a href="#故事从26行开始" class="headerlink" title="故事从26行开始"></a>故事从26行开始</h2><p>​    代码26行<code>all += ll(mul[i]) * dt[i];</code>相当奇怪，这是我wa了三次的原因，mul[i]最大取值应该是$2\times10^5$,dt[i]的最大取值应该是$10^5$，理论上最大取值应该是$2\times10^{10}$,刚好不超过int的范围，但是这题大概是出题人搞事情的吧，总之这里如果不使得计算结果为<code>long long</code>会导致<strong>WA</strong>。</p><p>​    联想到最近一次又一次的<strong>TLE</strong>,我感觉是时候正视题目上方的时间空间限制了。</p><h3 id="变量范围"><a href="#变量范围" class="headerlink" title="变量范围"></a>变量范围</h3><p>​    ok，第一步，先搞懂基本的变量范围。</p><p><img src="https://s1.ax1x.com/2023/01/18/pS3vrkD.png" alt="变量范围"></p><h4 id="能开多少"><a href="#能开多少" class="headerlink" title="能开多少"></a>能开多少</h4><p>268,435,456B=262144KB=256MB</p><p>B就是Byte，也就是所谓的字节</p><p>1Byte为8bit，也可以通过这个简单的估算整型的大小</p><p>可以简单估算得到下表</p><div class="table-container"><table><thead><tr><th>类型</th><th>大约能开多少</th><th>最大值</th></tr></thead><tbody><tr><td>(u)char/bool</td><td>$2.5\times10^9(实际10^8)$</td><td>(255)127/1</td></tr><tr><td>int</td><td>$6.7\times10^8(实际10^7)$</td><td>$2\times10^{10}$</td></tr><tr><td>long long</td><td>$3.3\times10^8(实际10^7)$</td><td>$9\times10^{19}$</td></tr></tbody></table></div><p><strong>以上数据以256M为准</strong></p><h3 id="时间限制"><a href="#时间限制" class="headerlink" title="时间限制"></a>时间限制</h3><p>这张图选自<code>AOP</code>的小群，原出处不明</p><p><img src="https://s1.ax1x.com/2023/01/18/pS3vste.jpg" alt="常见时间限制对应时间复杂度呃算法"></p><p>希望2023年我能看懂这张图</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/46810/D&quot;&gt;https://ac.nowcoder.com/acm/contest/46810/D&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;
&lt;p&gt;Tokitsukaze 有 nnn 个节点的有根能量树，根为 111。最开始，树上每个节点的能量都是 000。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://www.lymone.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="ACM" scheme="http://www.lymone.cc/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>关于三体TV版</title>
    <link href="http://www.lymone.cc/p/av170001.html"/>
    <id>http://www.lymone.cc/p/av170001.html</id>
    <published>2023-01-15T16:15:00.000Z</published>
    <updated>2023-03-03T13:04:08.332Z</updated>
    
    <content type="html"><![CDATA[<p>第一、艺画开天版三体就是依托答辩</p><p>第二、绝对不漏判任何一件坏事</p><p>第三、还是TM的公平</p><span id="more"></span><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>​    异化开天真的让我看到了三体改编作品的底线，今天（23.1.15）在看腾讯/央视版之前，就已经做好最坏的打算去看了，完全没想到，没想到啊家人们！</p><p>​    NB，plus！</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>​    咱就是说，好不容易有个好作品，最好还是<strong>支持正版</strong>哈，有机会看看央视的就看看央视，有钱充腾讯的就充腾讯。俺这种穷人想看<del>又菜又爱玩</del>又扛不住腾讯的广告影响观感的，只能搞歪门邪道=D。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="1-懒人，简单快捷"><a href="#1-懒人，简单快捷" class="headerlink" title="1.懒人，简单快捷"></a>1.懒人，简单快捷</h4><p>直接点击播放即可</p><p>播放地址（第一时间更新）：</p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/i0045u918s5.html">第一集</a></p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/d0045caapwc.html">第二集</a></p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/p0045qpgktl.html">第三集</a></p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/x0045levh1j.html">第四集</a></p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/k00459ddq2f.html">第五集</a></p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/s00453h4di9.html">第六集</a></p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/v0045hnpdhr.html">第八集</a></p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/l00455u3s27.html">第九集</a></p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/a0045ouf83f.html">第10集</a></p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/v0045g0h2bi.html">第11集</a></p><p><a href="https://jx.jsonplayer.com/player/?url=https://v.qq.com/x/cover/mzc002007knmh3g/r0045d9xgtg.html">第12集</a></p><h4 id="2-使用脚本，一劳永逸"><a href="#2-使用脚本，一劳永逸" class="headerlink" title="2.使用脚本，一劳永逸"></a>2.使用脚本，一劳永逸</h4><p>推荐脚本：</p><p><a href="https://greasyfork.org/zh-CN/scripts/370634-懒人专用-全网vip视频免费破解去广告-全网音乐直接下载-知乎增强-短视频无水印下载-百度网盘直接下载等多功能工具箱-功能可独立开关-长期更新-放心使用-v6">懒人专用，全网VIP视频免费破解去广告、全网音乐直接下载、知乎增强、短视频无水印下载、百度网盘直接下载等多功能工具箱，功能可独立开关。长期更新，放心使用。v6 (greasyfork.org)</a></p><p>先安装油猴。edge,chrome等主流浏览器都可用。</p><p>开启脚本后刷新播放页面在浏览器左侧有弹窗，建议选择<code>B站</code>（顶级NTR）</p><p>剩下的应该不用我多说了。</p><h3 id="呜呼（剧透警告）"><a href="#呜呼（剧透警告）" class="headerlink" title="呜呼（剧透警告）"></a>呜呼（剧透警告）</h3><p>以下是我对目前播放的电视剧的某些看法</p><h4 id="1-史强的味不够足啊"><a href="#1-史强的味不够足啊" class="headerlink" title="1.史强的味不够足啊"></a>1.史强的味不够足啊</h4><p>​    有可能是因为<code>艺画开天</code>的三体对我造成了影响，其实<code>于和伟</code>的大强还是蛮符合人设的，粗中有细。但是总是感觉有点放不开（可能因为动画的史强放的太开了）。</p><h4 id="2-南门二画错了啊"><a href="#2-南门二画错了啊" class="headerlink" title="2.南门二画错了啊"></a>2.南门二画错了啊</h4><p>​    第二集末尾出现的南门二（半人马α）画面应该是错了，画面上三个恒星分别的红色，黄色，白色。</p><p>但是，but:</p><div class="table-container"><table><thead><tr><th>恒星</th><th>行等</th><th>颜色</th></tr></thead><tbody><tr><td>半人马座α星A/南门二A</td><td>G2V型主序星</td><td>黄色</td></tr><tr><td>半人马座α星B/南门二B</td><td>K1V型主序星</td><td>红色</td></tr><tr><td>半人马座α星C/比邻星</td><td>M5V型红矮星</td><td>暗红色</td></tr></tbody></table></div><p><img src="https://p0.itc.cn/q_70/images01/20210612/5158081b4ca24b4f937cd769f5f31901.jpeg" alt="南门二"></p><h4 id="3-三体游戏"><a href="#3-三体游戏" class="headerlink" title="3.三体游戏"></a>3.三体游戏</h4><p>​    最近很忙，没来得及看最新的剧集，感觉三体游戏应该很有意思吧</p><h4 id="4-红岸基地"><a href="#4-红岸基地" class="headerlink" title="4.红岸基地"></a>4.红岸基地</h4><p>​    红岸部分，以及叶文洁的故事，在不影响过审的情况下，几乎做到了不影响叙事，我觉得这是非常值得认可的。</p><h4 id="5-王传君演丁仪"><a href="#5-王传君演丁仪" class="headerlink" title="5.王传君演丁仪"></a>5.王传君演丁仪</h4><p>​    有点无语，微博人是没事干了吗，王传君不演的挺好的。不过如果把球状闪电作为三体前传来看的话，这个时期的丁仪不太应该是这种精神状态，不过这个也应该是导演的锅，不该是演员的问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第一、艺画开天版三体就是依托答辩&lt;/p&gt;
&lt;p&gt;第二、绝对不漏判任何一件坏事&lt;/p&gt;
&lt;p&gt;第三、还是TM的公平&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://www.lymone.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="三体" scheme="http://www.lymone.cc/tags/%E4%B8%89%E4%BD%93/"/>
    
    <category term="大刘" scheme="http://www.lymone.cc/tags/%E5%A4%A7%E5%88%98/"/>
    
  </entry>
  
  <entry>
    <title>戴森球计划BepInEx模组开发日志</title>
    <link href="http://www.lymone.cc/p/ec842848.html"/>
    <id>http://www.lymone.cc/p/ec842848.html</id>
    <published>2023-01-07T16:04:35.000Z</published>
    <updated>2023-03-03T13:04:08.331Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近又把戴森球计划(Dyson Sphere Program)下回来了，并且发现有个叫创世之书模组挺有意思的。了解到现在模组作者都苦于游戏的数字ID，决定尝试一下能不能解决这个问题。解决问题第二步，选择框架并尝试进行模组开发。</p><span id="more"></span><p><strong>以下部分摘抄xiaoye97版本的BIE教程</strong></p><h1 id="开始编写插件"><a href="#开始编写插件" class="headerlink" title="开始编写插件"></a>开始编写插件</h1><p>我们给默认的Class1修改一个我们想要的名字，我这里改为PluginTutorial，然后将BepInEx的命名空间using一下。</p><p>在BepInEx中，给我们准备了一个类，BaseUnityPlugin，这是继承于MonoBehaviour的，也就是说，我们的插件，最终会以组件的形式挂载，实际上也是这样，每个插件最终都会挂载到游戏中BepInEx的物体身上。所以我们可以使用MonoBehaviour的各种生命周期，比如Awake，Start，Update等等，这些我们以后再说，先来看一下最基础的插件的样子。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> BepInEx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PluginTutorial</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//插件描述特性 分别为 插件ID 插件名字 插件版本(必须为数字)</span></span><br><span class="line">    [<span class="meta">BepInPlugin(<span class="string">&quot;me.xiaoye97.plugin.Tutorial&quot;</span>, <span class="string">&quot;Tutorial Plugin&quot;</span>, <span class="string">&quot;1.0&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PluginTutorial</span> : <span class="title">BaseUnityPlugin</span> <span class="comment">//继承BaseUnityPlugin</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Unity的Start生命周期</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//输出日志</span></span><br><span class="line">            Logger.LogInfo(<span class="string">&quot;HelloWorld!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将PluginTutorial继承BaseUnityPlugin，并在类上方添加了一个叫做BepInPlugin的特性，这是必须要完成的，只有这样才能正确加载插件。</p><p>如果你不知道特性是什么，可以去补一下C#关于特性方面的知识。</p><p>在BepInPlugin特性中，我们填入了3个参数，分别是插件的ID，插件的名字，插件的版本号，对于ID，我个人习惯使用域名反写法，一般是me.xiaoye97.plugin.游戏名.插件名，插件的名字没有什么特别的要求，直观即可。在插件版本这里，必须是数字形式的版本号，不能夹杂字母等。</p><h1 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h1><p>插件的特性除了BepInExPlugin之外，还有两个可能会用到的特性。</p><p>第一个是BepInProcess特性，大部分情况下，我们不需要写这个特性，但是偶尔会遇到特殊情况。比如，在I社游戏(例如AI少女、恋爱活动等)中，不仅有游戏本体，还有一个工作室程序，将游戏本体与内容创作进行了分割，这样，就会有两个exe，但是，他们是两个不同的exe，有很多地方是不能公用的。那么，只需要用这个特性，就可以限制插件在指定的exe上可以运行。<br>例如</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">BepInPlugin(<span class="string">&quot;me.xiaoye97.plugin.Tutorial&quot;</span>, <span class="string">&quot;Tutorial Plugin&quot;</span>, <span class="string">&quot;1.0&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">BepInProcess(<span class="string">&quot;Maid In Makai.exe&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PluginTutorial</span> : <span class="title">BaseUnityPlugin</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就是限定只在这个exe中运行，如果想限制在几个exe中可以运行，就继续添加这样特性即可。</p><p>第二个是BepInDependency特性，如果我们的插件，需要以其他的什么插件为前置插件，那么就需要使用这个特性添加依赖，以保证只有在有前置插件的情况下加载我们的插件。</p><p>BepInDependency特性有3种写法，分别是</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">BepInPlugin(<span class="string">&quot;me.xiaoye97.plugin.Tutorial&quot;</span>, <span class="string">&quot;Tutorial Plugin&quot;</span>, <span class="string">&quot;1.0&quot;</span>)</span>]</span><br><span class="line"><span class="comment">// 软依赖，如果没有前置插件，依旧继续加载</span></span><br><span class="line">[<span class="meta">BepInDependency(<span class="string">&quot;com.bepinex.plugin.somedependency&quot;</span>, BepInDependency.DependencyFlags.SoftDependency)</span>]</span><br><span class="line"><span class="comment">// 硬依赖，如果没有前置插件，则停止加载</span></span><br><span class="line">[<span class="meta">BepInDependency(<span class="string">&quot;com.bepinex.plugin.importantdependency&quot;</span>, BepInDependency.DependencyFlags.HardDependency)</span>]</span><br><span class="line"><span class="comment">// 省略参数，则默认为硬依赖</span></span><br><span class="line">[<span class="meta">BepInDependency(<span class="string">&quot;com.bepinex.plugin.anotherimportantone&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PluginTutorial</span> : <span class="title">BaseUnityPlugin</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了这些特性之外，还有一点我们需要注意的是，一个dll中可以包括多个插件，只要我们写多个继承BaseUnityPlugin的类，并为他们赋予BepInPlugin特性即可。</p><h1 id="ConfigEntry"><a href="#ConfigEntry" class="headerlink" title="ConfigEntry"></a>ConfigEntry<T></h1><p>在插件功能的设计中，经常会有需要玩家自己配置的东西，比如插件的各种设置，快捷键的分配等。在BepInEx中，提供了一个ConfigEntry类简化了配置操作。</p><p>我们来看一段示例：</p><p>(注:由于阿B在代码页中会删除尖括号，所以我使用空格隔开)</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BepInEx;</span><br><span class="line"><span class="keyword">using</span> BepInEx.Configuration; <span class="comment">//ConfigEntry的命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PluginTutorial</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">BepInPlugin(<span class="string">&quot;me.xiaoye97.plugin.Tutorial&quot;</span>, <span class="string">&quot;Tutorial Plugin&quot;</span>, <span class="string">&quot;1.0&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PluginTutorial</span> : <span class="title">BaseUnityPlugin</span></span><br><span class="line">    &#123;</span><br><span class="line">        ConfigEntry&lt;<span class="built_in">int</span>&gt; intConfig;</span><br><span class="line">        ConfigEntry&lt;<span class="built_in">string</span>&gt; stringConfig;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//绑定配置文件</span></span><br><span class="line">            intConfig = Config.Bind&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;TestInt&quot;</span>, <span class="number">10</span>, <span class="string">&quot;测试用Int&quot;</span>);</span><br><span class="line">            stringConfig = Config.Bind&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;config&quot;</span>, <span class="string">&quot;TestString&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;测试用String&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用配置文件中的值</span></span><br><span class="line">            Logger.LogInfo(intConfig.Value);</span><br><span class="line">            Logger.LogInfo(stringConfig.Value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Config是BaseUnityPlugin的成员，是每个插件都自带的，通过这个Config进行绑定时，会自动以插件ID为文件名生成配置文件，如果你需要多个配置文件，可以手动创建ConfigFile对象。</p><p>绑定时有4个参数，分别是 分类 Key 默认值 描述。分类就是这个配置在哪个标签下，比如我们之前打开控制台窗口的时候，是在[Logging.Console]下，Key则是这个配置的名字，比如打开控制台时的Enabled，默认值则是在没有配置文件的情况下，创建配置文件时使用的值，描述可填可不填，主要是提醒玩家这个配置的用处是什么。</p><h1 id="使用ConfigurationManager在游戏运行时修改配置文件"><a href="#使用ConfigurationManager在游戏运行时修改配置文件" class="headerlink" title="使用ConfigurationManager在游戏运行时修改配置文件"></a>使用ConfigurationManager在游戏运行时修改配置文件</h1><p>BepInEx有多个非常实用的通用插件，放在任何游戏都可以使用，本章介绍ConfigurationManager插件，它可以在游戏内可视化的修改配置文件。</p><p>下载地址：<a href="https://github.com/BepInEx/BepInEx.ConfigurationManager/releases">https://github.com/BepInEx/BepInEx.ConfigurationManager/releases</a></p><p>安装插件后，在游戏中按F1打开配置管理界面，修改即可。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过之前的教程，我们已经知道如何编写基本的插件，如果你有C#和Unity的基础，这个时候已经可以做出一些功能了，比如通过按键修改游戏数据之类的。但是，这有很大的局限性，因为通常情况下，我们并不想通过按键来调用我们的功能，我们想让大多数的功能都是加载之后就不需要管了，或者想做一些普通情况下比较难以操作的事情。这个时候，通过Harmony进行补丁可以解决我们绝大多数的需求。</p><p>Harmony的github链接 <a href="https://github.com/pardeike/Harmony">https://github.com/pardeike/Harmony</a> 详细信息可以在github查看。</p><p>Harmony中使用最频繁的两个地方就是前置补丁和后置补丁，也是最简单的，本篇文章主要就讲这两种。一些特殊的需求需要修改函数本身也是可以的，Harmony支持修改函数的IL码，不过这个就不在基础的范畴了，以后有机会的话会放在进阶篇来讲。</p><h1 id="HarmonyPatch特性"><a href="#HarmonyPatch特性" class="headerlink" title="HarmonyPatch特性"></a>HarmonyPatch特性</h1><p>要对游戏中的方法进行补丁，首先我们需要确定一个目标，这里我准备了一个类，我们就以这个类为例子，对它进行补丁。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">People</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age&#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Sleep</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Say</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Say</span>(<span class="params"><span class="built_in">string</span> content</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Say</span>(<span class="params"><span class="built_in">int</span> content</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的People类，有两个属性，分别是姓名和年龄，一个构造函数，一个Sleep方法，还有3个说话的方法，使用了3种重载。</p><p>以Sleep方法为例，我们写一个最简单的补丁。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HarmonyPatch(typeof(People), <span class="string">&quot;Sleep&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">PeopleSleepPatch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Postfix</span>(<span class="params">People __instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(__instance.Name + <span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的HarmonyPatch特性就用于确定补丁目标，这个特性的参数可以写在一排也可以分成几排写。例子中的两个参数分别是要补丁的类型，还有要补丁的方法的名字。这是最简单的情况，实际上我们还经常会遇到其他几种情况。比如，Say方法有3个重载，如何确定要补丁哪一个？属性要怎么补丁？我们再来看几个例子。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HarmonyPatch(typeof(People), <span class="string">&quot;Say&quot;</span>, new Type[</span>] &#123; &#125;)]</span><br><span class="line">[<span class="meta">HarmonyPatch(typeof(People), <span class="string">&quot;Say&quot;</span>, new Type[</span>] &#123; <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;)]</span><br><span class="line">[<span class="meta">HarmonyPatch(typeof(People), <span class="string">&quot;Say&quot;</span>, new Type[</span>] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;)]</span><br></pre></td></tr></table></figure><p>如此，面对有重载的情况，我们只需要在添加一个参数，这个参数是一个Type数组，我们按顺序将参数类型填入即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HarmonyPatch(typeof(People), <span class="string">&quot;Name&quot;</span>, MethodType.Getter</span>]</span><br><span class="line">[<span class="meta">HarmonyPatch(typeof(People), <span class="string">&quot;Age&quot;</span>, MethodType.Setter</span>]</span><br><span class="line">[<span class="meta">HarmonyPatch(typeof(People), MethodType.Constructor</span>]</span><br></pre></td></tr></table></figure><p>面对属性和构造函数，我们可以使用MethodType枚举来当作参数。需要注意的是，补丁构造函数时，函数名不能写dnSpy中看到的.ctor，而是应该直接省略不写函数名。</p><h1 id="补丁方法"><a href="#补丁方法" class="headerlink" title="补丁方法"></a>补丁方法</h1><p>既然已经可以确定补丁目标了，接下来让我们了解一下最基础最常用的两种补丁方法，Prefix(前置补丁)、Postfix(后置补丁)。</p><p>先说后置补丁，这是最简单的，它在补丁目标运行结束之后运行，上面示例中的就是后置补丁，可以使用__result参数接收目标的返回值。</p><p>然后是前置补丁，顾名思义，它是在补丁目标运行之前运行的，这个相对复杂一点。因为我们可以选择是否执行原方法。我们来看两个例子。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HarmonyPatch(typeof(People), <span class="string">&quot;Say&quot;</span>,  new Type[</span>] &#123; <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;)]</span><br><span class="line"><span class="keyword">class</span> <span class="title">PeopleSayPatch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Prefix</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> content</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        content = <span class="string">&quot;要说的内容已被修改&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">HarmonyPatch(typeof(People), <span class="string">&quot;Name&quot;</span>,  MethodType.Getter)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">PeopleNamePatch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Prefix</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> __result</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        __result = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//拦截原方法，直接使用我们给出的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个例子，我们将content的值修改为了我们自己想要的值，然后返回true表示让原函数继续执行。第二个例子，我们直接将最终结果修改，然后返回false，表示阻止原函数执行。如果你搞不明白IL代码，不知道如何修改函数本体，也可以通过前置补丁的方式自己计算结果然后修改。</p><h1 id="补丁参数"><a href="#补丁参数" class="headerlink" title="补丁参数"></a>补丁参数</h1><p>在上面的例子中，我们有时候使用了<strong>instance，有时候使用了</strong>result，想必读者还留有疑问，为什么要这么写。其实，这是Harmony作者为我们定好的获取方法信息的方式。</p><p>大概情况如下:</p><ul><li>补丁方法<strong>必须</strong>是<strong>静态</strong>方法</li><li>Prefix需要返回<strong>void</strong>或者<strong>bool</strong>类型(void即不拦截)</li><li>Postfix需要返回<strong>void</strong>类型，或者返回的类型要与<strong>第一个</strong>参数一致(直通模式)</li><li>如果原方法不是静态方法，则可以使用名为<strong>__instance</strong>(两个下划线)的参数来访问对象实例</li><li>可以使用名为<strong>__result</strong>(两个下划线)的参数来访问方法的返回值，如果是Prefix，则得到返回值的默认值</li><li>可以使用名为<strong>__state</strong>(两个下划线)的参数在Prefix补丁中存储任意类型的值，然后在Postfix中使用它，你有责任在Prefix中初始化它的值</li><li>可以使用与原方法中<strong>同名的参数</strong>来访问对应的参数，如果你要写入非引用类型，记得使用ref关键字</li><li>补丁使用的参数必须<strong>严格对应</strong>类型(或者使用object类型)和名字</li><li>我们的补丁只需要定义我们需要用到的参数，不用把所有参数都写上</li><li>要允许补丁重用，可以使用名为<strong>__originalMethod</strong>(两个下划线)的参数注入原始方法</li></ul><p>Transpilers还有一些可选参数，我们这里不做探讨，想了解可以访问Harmony的wiki。</p><h1 id="自动补丁"><a href="#自动补丁" class="headerlink" title="自动补丁"></a>自动补丁</h1><p>补丁的情况我们大体介绍完了，但是我们现在只是写了补丁，还没有对游戏进行补丁，其实很简单，我们只要在插件加载的时候，加上一句代码就好。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Harmony(<span class="string">&quot;me.xiaoye97.plugin.Tutorial&quot;</span>).PatchAll(); <span class="comment">//以作者输入的字符串作为ID，对程序集中所有找到的补丁方法进行补丁。</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Harmony.CreateAndPatchAll(<span class="keyword">typeof</span>(PluginTutorial)); <span class="comment">//Harmony以类名为ID进行补丁，并且只补丁此类下的方法。</span></span><br></pre></td></tr></table></figure><p>除了自动补丁之外，还可以进行手动补丁，可以更加细微的控制，就不在基础教程中说了，读者可以通过GitHub继续了解，以后的教程如果遇到需要手动补丁的情况我再继续讲解。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>对于新接触BepInEx或者UnityModManager Mod开发的人来说，Harmony可能比较陌生，如果看了本篇教程之后还是感觉不太好下手，可以使用dnSpy反编译其他人制作的插件，或者如果他们有开源的话，可以直接查看开源的代码进行学习模仿。我在我的Github上也放了几个小插件，大家可以查看学习。</p><p>我的Github地址：<a href="https://github.com/xiaoye97">https://github.com/xiaoye97</a></p><hr><p>23.1.8 02:41</p><p>突然发觉给DSP换个英文ID是非常大的工程</p><p>并且我可能需要一套完整的解决方案和处理流程</p><p>例如ABN_RecipeUnlockCondition.cs中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (recipeProto.preTech == null || this.gameData.history.TechUnlocked(recipeProto.preTech.ID))</span><br></pre></td></tr></table></figure><p>的使用，显然this.gameData.history.TechUnlocked传参为int</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public bool TechUnlocked(int techId) =&gt; this.techStates.ContainsKey(techId) &amp;&amp; this.techStates[techId].unlocked;</span><br></pre></td></tr></table></figure><p>如果我想更改为英文ID，这些判定有关的需要全部从做</p><p>===</p><p><a href="https://docs.unity3d.com/cn/2020.3/Manual/ExecutionOrder.html">事件函数的执行顺序 - Unity 手册 (unity3d.com)</a></p><p>Unity脚本生命周期</p><p>===</p><p><strong>以下部分为3DM MOD版教程</strong></p><p>一个示例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> BepInEx;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyFirstBepInExMod</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">BepInPlugin(<span class="string">&quot;aoe.top.plugins.MyFirstBepInExMod&quot;</span>, <span class="string">&quot;这是我的第一个BepIn插件&quot;</span>, <span class="string">&quot;1.0.0.0&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyFirstBepInExMod</span> : <span class="title">BaseUnityPlugin</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在插件启动时会直接调用Awake()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用Debug.Log()方法来将文本输出到控制台</span></span><br><span class="line">            Debug.Log(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在所有插件全部启动完成后会调用Start()方法，执行顺序在Awake()后面；</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;这里是Start()方法中的内容!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插件启动后会一直循环执行Update()方法，可用于监听事件或判断键盘按键，执行顺序在Start()后面</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> key = <span class="keyword">new</span> BepInEx.Configuration.KeyboardShortcut(KeyCode.F9);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key.IsDown())</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;这里是Updatet()方法中的内容，你看到这条消息是因为你按下了F9&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在插件关闭时会调用OnDestroy()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;当你看到这条消息时，就表示我已经被关闭一次了!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HarmonyPrefix"><a href="#HarmonyPrefix" class="headerlink" title="HarmonyPrefix"></a>HarmonyPrefix</h3><p>HarmonyPrefix是Harmony为我们提供的一个接口，它将在我们指定的函数前进行执行，并且我们可以返回一个bool值来控制是否继续继续执行游戏原函数；<br>需要配合HarmonyPatch一起使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 19 个重载</span><br><span class="line">public HarmonyPatch();</span><br><span class="line">public HarmonyPatch(Type declaringType);</span><br><span class="line">public HarmonyPatch(MethodType methodType);</span><br><span class="line">public HarmonyPatch(string methodName);</span><br><span class="line">public HarmonyPatch(Type[] argumentTypes);</span><br><span class="line">public HarmonyPatch(MethodType methodType, params Type[] argumentTypes);</span><br><span class="line">public HarmonyPatch(string methodName, MethodType methodType);</span><br><span class="line">public HarmonyPatch(string methodName, params Type[] argumentTypes);</span><br><span class="line">public HarmonyPatch(Type[] argumentTypes, ArgumentType[] argumentVariations);</span><br><span class="line">public HarmonyPatch(Type declaringType, MethodType methodType);</span><br><span class="line">public HarmonyPatch(Type declaringType, string methodName);</span><br><span class="line">public HarmonyPatch(Type declaringType, Type[] argumentTypes);</span><br><span class="line">public HarmonyPatch(Type declaringType, string methodName, MethodType methodType);</span><br><span class="line">public HarmonyPatch(string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations);</span><br><span class="line">public HarmonyPatch(Type declaringType, string methodName, params Type[] argumentTypes);</span><br><span class="line">public HarmonyPatch(MethodType methodType, Type[] argumentTypes, ArgumentType[] argumentVariations);</span><br><span class="line">public HarmonyPatch(Type declaringType, MethodType methodType, params Type[] argumentTypes);</span><br><span class="line">public HarmonyPatch(Type declaringType, string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations);</span><br><span class="line">public HarmonyPatch(Type declaringType, MethodType methodType, Type[] argumentTypes, ArgumentType[] argumentVariations);</span><br><span class="line">public HarmonyPatch(string assemblyQualifiedDeclaringType, string methodName, MethodType? methodType = null, Type[] argumentTypes = null, ArgumentType[] argumentVariations = null);</span><br></pre></td></tr></table></figure><p>如：<br>我们想要对Mecha类下的SetForNewGame函数进行拦截，那么就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[HarmonyPrefix]</span><br><span class="line">[HarmonyPatch(typeof(Mecha), &quot;SetForNewGame&quot;)]</span><br><span class="line">public static bool Mecha_SetForNewGame_Prefix()</span><br><span class="line">&#123;</span><br><span class="line">    // 这里写入我们自己的内容            </span><br><span class="line">    Debug.Log(&quot;这里的内容将会在游戏函数执行前进行执行&quot;);</span><br><span class="line">    // 返回 true为继续执执行游戏原函数，返回 false为不执行游戏原函数,</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HarmonyPostfix"><a href="#HarmonyPostfix" class="headerlink" title="HarmonyPostfix"></a>HarmonyPostfix</h3><p>HarmonyPostfix一样也是Harmony为我们提供的一个接口，它将在我们指定的函数执行完毕后，再执行。<br>一样需要配合HarmonyPatch一起使用</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[HarmonyPostfix]</span><br><span class="line">[HarmonyPatch(typeof(Mecha), &quot;SetForNewGame&quot;)]</span><br><span class="line">public static void Mecha_SetForNewGame_Postfix()</span><br><span class="line">&#123;</span><br><span class="line">    // 这里写入我们自己的内容            </span><br><span class="line">    Debug.Log(&quot;这里的内容需要等待游戏原函数执行完后才会执行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>1.我们的函数需要使用static静态函数，不然会报错；<br>2.函数名可以自定义，但尽量不要和游戏原有函数冲突；<br>3.两种拦截方式大同小异，希望大家举一反三。</p></blockquote><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在游戏原函数中难免会出现this参数，万能的Harmony当然也考虑到了这一点，针对于this，我们可以向函数中传递一个__instance。</p><p>游戏原函数内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void SetForNewGame()</span><br><span class="line">&#123;</span><br><span class="line">    ModeConfig freeMode = Configs.freeMode;</span><br><span class="line">    this.coreEnergyCap = freeMode.mechaCoreEnergyCap;</span><br><span class="line">    this.coreEnergy = this.coreEnergyCap;</span><br><span class="line">    this.corePowerGen = freeMode.mechaCorePowerGen;</span><br><span class="line">    this.reactorPowerGen = freeMode.mechaReactorPowerGen;</span><br><span class="line">    this.reactorEnergy = 0.0;</span><br><span class="line">    this.reactorItemId = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[HarmonyPostfix]</span><br><span class="line">[HarmonyPatch(typeof(Mecha), &quot;SetForNewGame&quot;)]</span><br><span class="line">public static void Mecha_SetForNewGame_Postfix(Mecha __instance)</span><br><span class="line">&#123;</span><br><span class="line">    ModeConfig freeMode = Configs.freeMode;</span><br><span class="line">    __instance.coreEnergyCap = freeMode.mechaCoreEnergyCap;</span><br><span class="line">    __instance.coreEnergy = __instance.coreEnergyCap;</span><br><span class="line">    __instance.corePowerGen = freeMode.mechaCorePowerGen;</span><br><span class="line">    __instance.reactorPowerGen = freeMode.mechaReactorPowerGen;</span><br><span class="line">    __instance.reactorEnergy = 0.0;</span><br><span class="line">    __instance.reactorItemId = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注释：</p><ul><li>Mecha<code>__instance</code>中，<code>Mecha</code> 为当前类的名称，<code>__instance</code>为Harmony的固有写法（有两个“_”）；</li><li>这种方法只限于操作公共public变量和函数；</li></ul></blockquote><h3 id="游戏私有变量"><a href="#游戏私有变量" class="headerlink" title="游戏私有变量"></a>游戏私有变量</h3><p>刚刚提到，“__instance”只能获取游戏的公共变量和方法，如果我们要获取游戏中私有的变量和方法的话，就需要用到Traverse工具；<br>我们可以通过Traverse工具,方便访问游戏里所有公有,私有,受保护的变量,方法,以及属性,</p><p>如我们想获取游戏中的变量，那么在我们的插件中就可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[HarmonyPostfix]</span><br><span class="line">[HarmonyPatch(typeof(Mecha), &quot;SetForNewGame&quot;)]</span><br><span class="line">public static void Mecha_SetForNewGame_Postfix(Mecha __instance)</span><br><span class="line">&#123;</span><br><span class="line">    // 获取 private float _dronesSpeed; 的值</span><br><span class="line">    var _droneCount= Traverse.Create(__instance).Field(&quot;_droneCount&quot;).GetValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><blockquote><p>来自 <a href="https://bbs.3dmgame.com/thread-5870433-1-1.html">https://bbs.3dmgame.com/thread-5870433-1-1.html</a><br><strong>关于Traverse的使用:</strong><br>Traverse是harmony类库下的一个工具类,也就是在一开始引用的using harmony;这条语句后,方便我们使用的一个类,首先我们要明白private和public还有protected三个关键词的区别,具体可以百度,我这里仅从结论讲明,除了public,其他的private和protected从外界是无法访问到的,但是用Traverse类不管它是public,private,protected,均可以强行访问,为什么不任何地方都使用Traverse去访问呢,因为性能问题,用Traverse要走映射,简单来说运行速度会有些许影响</p><p>Traverse的具体使用方法简单的来说明一下,Traverse.create(类的实例),表名我要将一个类的实例转为Traverse对象,简单来说就是附加功能,比如我们以前都是自己买菜,后来有了XX外卖,我们不需要亲力亲为了,XX外卖就等于Traverse对象了(这里就是将映射功能简单化了,不需要自己打代码了),这样我们就有一个可以访问类实例的Traverse对象了,在上面法宝的例子中,我是直接写为了<br>var itemID = Traverse.Create(<strong>instance).Field(“itemID”).GetValue();<br>这是一种简化的写法的,下面我分开并且逐步注释一下<br>Traverse t = Traverse.Create(</strong>instance);//根据__instance (ToilRefining类的实例) 创建 Traverse对象,并且用t表示<br>Traverse f = t.Field(“itemID”);//在ToilRefining实例里面有个itemID的字段,找到他并且创建一个Traverse对象,用f表示,这样可以强行访问 itemID,因为itemID是私有的没法直接访问<br>int itemID = f.GetValue();//将Traverse版本的itemID提取成可以直接访问的数值,因为Traverse并不知道原本itemID是什么类型的,所以我们要用标注这是个int类型了,从源代码中我们可以知道itemID的变量类型,对应修改即可<br>于是我们就访问到itemID了<br>既然有获取,自然就有修改,修改我们可以用f.SetValue(数值),这里就不需要指定了,因为你在输入数值的时候,他会自动把你输入的数据转成对应的类型</p><p>这里我说一下字段,属性,方法的意思,这是C#的基础,字段代表类变量,可以理解为类中的全局变量,可以再类中任意地方访问到</p><p>属性是字段的升级版,他在源代码中的样子是这样的</p><p>他跟字段的定义差不多,但是后面会有括号,里面还有set和get,这种样子的就是属性,我们不能通过Traverse.Field(字段名字),而是通过Traverse.Property(属性名字)来访问,如果定义中只有get,表名这个东西只能获取,不能更改(就是游戏开发者也不能),get和set都在就是可以获取也可以更改</p><p>最后就是方法,在C#中称为方法,C语言中称为函数,比如游戏源码中,MakeFaBao就是制作法宝的方法,他定义时后面跟随的是()这种括号,我们想要访问游戏private的方法可以用Traverse.Method(方法名字).GetValue()来运行,注意后面要加上.GetValue(),因为仅仅Traverse.Method(方法名字)是获取的方法的Traverse对象,而没有运行他</p><p>C#中有一个关键词是var,这个关键词是这个变量是智能根据你后面赋值来判断他的变量类型的<br>比如 var a = 6;//a是int类型<br>var b = “我是文字”;//b就是string类型的<br>于是之前为了itemID那么多行的代码就可以省略为var itemID = Traverse.Create(<strong>instance).Field(“itemID”).GetValue();一句话搞定<br>当然也可以var t = Traverse.Create(</strong>instance);<br>var itemID = t.Field(“itemID”).GetValue();var XXXX = t.Field(“XXXX”).GetValue();<br>来多次获取</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    最近又把戴森球计划(Dyson Sphere Program)下回来了，并且发现有个叫创世之书模组挺有意思的。了解到现在模组作者都苦于游戏的数字ID，决定尝试一下能不能解决这个问题。解决问题第二步，选择框架并尝试进行模组开发。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C#" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="Unity" scheme="http://www.lymone.cc/tags/Unity/"/>
    
    <category term="BepInEx" scheme="http://www.lymone.cc/tags/BepInEx/"/>
    
  </entry>
  
  <entry>
    <title>面向Unity的C#学习记录</title>
    <link href="http://www.lymone.cc/p/ddf9c66f.html"/>
    <id>http://www.lymone.cc/p/ddf9c66f.html</id>
    <published>2023-01-07T11:25:37.000Z</published>
    <updated>2023-03-03T13:04:08.329Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近又把戴森球计划(Dyson Sphere Program)下回来了，并且发现有个叫创世之书模组挺有意思的。了解到现在模组作者都苦于游戏的数字ID，决定尝试一下能不能解决这个问题。解决问题第一步，简单学一下C#。</p><span id="more"></span><h1 id="一、C-基础"><a href="#一、C-基础" class="headerlink" title="一、C#基础"></a>一、C#基础</h1><h2 id="1-我遇到的一些没见过东西"><a href="#1-我遇到的一些没见过东西" class="headerlink" title="1.我遇到的一些没见过东西"></a>1.我遇到的一些没见过东西</h2><h3 id="特性（Attribute）"><a href="#特性（Attribute）" class="headerlink" title="特性（Attribute）"></a>特性（Attribute）</h3><p><strong>特性（Attribute）</strong>是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。</p><p>特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：<em>预定义</em>特性和<em>自定义</em>特性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​    最近又把戴森球计划(Dyson Sphere Program)下回来了，并且发现有个叫创世之书模组挺有意思的。了解到现在模组作者都苦于游戏的数字ID，决定尝试一下能不能解决这个问题。解决问题第一步，简单学一下C#。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C#" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="Unity" scheme="http://www.lymone.cc/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://www.lymone.cc/p/e85d694a.html"/>
    <id>http://www.lymone.cc/p/e85d694a.html</id>
    <published>2022-10-05T08:14:40.000Z</published>
    <updated>2023-06-09T07:47:29.171Z</updated>
    
    <content type="html"><![CDATA[<p>直入主题</p><span id="more"></span><h2 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h2><p>先序遍历（先根）是先遍历<strong>当前节点</strong>，再遍历左子树，最后遍历右子树。</p><p>中序遍历（中根）是先遍历左子树，再遍历<strong>当前节点</strong>，最后遍历右子树。</p><p>后序遍历（后根）是先遍历左子树，再遍历右子树，最后遍历<strong>当前节点</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;直入主题&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://www.lymone.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="数据结构" scheme="http://www.lymone.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>疑点笔记</title>
    <link href="http://www.lymone.cc/p/72171c93.html"/>
    <id>http://www.lymone.cc/p/72171c93.html</id>
    <published>2022-10-04T02:39:19.000Z</published>
    <updated>2023-03-03T13:04:08.334Z</updated>
    
    <content type="html"><![CDATA[<p>今天刷题的时候，发现了一个有趣的东西</p><span id="more"></span><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>这是一个字符串输入的题目，输入的字符串中是带有空格的，所以关键点就在输入的处理上。</p><p>输入样例是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ 9</span><br><span class="line"> @  @@@@@</span><br><span class="line">@@@  @@@ </span><br><span class="line"> @   @ @ </span><br><span class="line">@@@  @@@ </span><br><span class="line">@@@ @@@@@</span><br><span class="line">@@@ @ @ @</span><br><span class="line">@@@ @@@@@</span><br><span class="line"> @  @ @ @</span><br><span class="line"> @  @@@@@</span><br></pre></td></tr></table></figure><p>在第一行输入结束后，缓冲区会残留下一个  <code>\n</code>，所以我首先使用如下方法进行处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;<span class="type">int</span> N;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c %d\n&quot;</span>,&amp;ch,&amp;N);</span><br></pre></td></tr></table></figure><p>这显然是可以工作的，<code>scanf</code>会忽略行末的<code>\n</code>；事实也是如此。</p><p>但是问题出在了下一行，使用这种方法之后，如果下一行的第一个字符是空格，将不会被<code>getline()</code>读入。</p><p>我在查找资料的过程中并未发现这个问题出现的原因。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>换用标准代码中的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; x &gt;&gt; n;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br></pre></td></tr></table></figure><p>或者使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c %d&quot;</span>,&amp;ch,&amp;N);</span><br><span class="line"><span class="built_in">getchar</span>();</span><br></pre></td></tr></table></figure><p>都不会出现这个问题</p><p>但是如果使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c %d\n&quot;</span>,&amp;ch,&amp;N);</span><br><span class="line"></span><br><span class="line"><span class="built_in">getchar</span>();</span><br></pre></td></tr></table></figure><p>不但第一个空格会消失，空格之后还会再消失一个有意义字符。</p><p>看来\n和那些空格确实是被忽略了。</p><p>继续变换了一下输入的数据，第二行第一个有意义字符前面含有多个空格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c %d\n&quot;</span>,&amp;ch,&amp;N);</span><br></pre></td></tr></table></figure><p>成功的使得前面这些所有空格都消失了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>按照这个实验结果来看</p><p><code>scanf</code>中如果使用\n来忽略换行输入，可能会同时忽略之后的空格</p><p>还是老老实实的输入然后<code>getchar()</code>吧</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天刷题的时候，发现了一个有趣的东西&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>7-10 排座位（25分）[并查集算法]</title>
    <link href="http://www.lymone.cc/p/b67676c7.html"/>
    <id>http://www.lymone.cc/p/b67676c7.html</id>
    <published>2022-10-03T02:00:25.000Z</published>
    <updated>2023-03-03T13:04:08.333Z</updated>
    
    <content type="html"><![CDATA[<p>置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。</p><span id="more"></span><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出3个正整数：<code>N</code>（≤100），即前来参宴的宾客总人数，则这些人从1到<code>N</code>编号；<code>M</code>为已知两两宾客之间的关系数；<code>K</code>为查询的条数。随后<code>M</code>行，每行给出一对宾客之间的关系，格式为：<code>宾客1 宾客2 关系</code>，其中<code>关系</code>为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后<code>K</code>行，每行给出一对需要查询的宾客编号。</p><p>这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出<code>No problem</code>；如果他们之间并不是朋友，但也不敌对，则输出<code>OK</code>；如果他们之间有敌对，然而也有共同的朋友，则输出<code>OK but...</code>；如果他们之间只有敌对关系，则输出<code>No way</code>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">7 8 4</span><br><span class="line">5 6 1</span><br><span class="line">2 7 -1</span><br><span class="line">1 3 1</span><br><span class="line">3 4 1</span><br><span class="line">6 7 -1</span><br><span class="line">1 2 1</span><br><span class="line">1 4 1</span><br><span class="line">2 3 -1</span><br><span class="line">3 4</span><br><span class="line">5 7</span><br><span class="line">2 3</span><br><span class="line">7 2</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">No problem</span><br><span class="line">OK</span><br><span class="line">OK but...</span><br><span class="line">No way</span><br></pre></td></tr></table></figure><p>代码长度限制</p><p>16 KB</p><p>时间限制</p><p>200 ms</p><p>内存限制</p><p>64 MB</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h3><p>22/25分代码如下</p><p>思路为暴力搜索</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> _friend[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> _energy[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">_friend[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">_energy[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> N, M, K;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line"><span class="type">int</span> p1, p2, rope;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; rope;</span><br><span class="line"><span class="keyword">if</span> (rope == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">_friend[p1][<span class="number">0</span>]++;</span><br><span class="line">_friend[p1][_friend[p1][<span class="number">0</span>]] = p2;</span><br><span class="line">_friend[p2][<span class="number">0</span>]++;</span><br><span class="line">_friend[p2][_friend[p2][<span class="number">0</span>]] = p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rope == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">_energy[p1][<span class="number">0</span>]++;</span><br><span class="line">_energy[p1][_energy[p1][<span class="number">0</span>]] = p2;</span><br><span class="line">_energy[p2][<span class="number">0</span>]++;</span><br><span class="line">_energy[p2][_energy[p2][<span class="number">0</span>]] = p1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> is_friend = <span class="literal">false</span>, is_energy = <span class="literal">false</span>;</span><br><span class="line">cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> xi = <span class="number">1</span>; xi &lt;= _friend[p1][<span class="number">0</span>]; xi++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_friend[p1][xi] == p2 || is_friend)</span><br><span class="line">&#123;</span><br><span class="line">is_friend = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> yi = <span class="number">1</span>; yi &lt;= _friend[p2][<span class="number">0</span>]; yi++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_friend[p1][xi] == _friend[p2][yi])</span><br><span class="line">&#123;</span><br><span class="line">is_friend = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> xi = <span class="number">1</span>; xi &lt;= _energy[p1][<span class="number">0</span>]; xi++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_energy[p1][xi] == p2)</span><br><span class="line">&#123;</span><br><span class="line">is_energy = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> xi = <span class="number">1</span>; xi &lt;= _energy[p2][<span class="number">0</span>]; xi++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_energy[p2][xi] == p1)</span><br><span class="line">&#123;</span><br><span class="line">is_energy = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10 00 11 01</span></span><br><span class="line"><span class="keyword">if</span> (is_friend)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (is_energy)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;OK but...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No problem&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (is_energy)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No way&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;OK&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个代码始终有一个数据过不去，原因不明。</p><h3 id="正确解题"><a href="#正确解题" class="headerlink" title="正确解题"></a>正确解题</h3><p>这个题目的解答要用到并查集算法</p><p>代码如下，后文有并查集补充</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> father[<span class="number">101</span>];</span><br><span class="line">    <span class="comment">//int rank[101];</span></span><br><span class="line">    <span class="built_in">DisjointSet</span>(<span class="type">int</span> N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            father[i]=i;</span><br><span class="line">            <span class="comment">//rank[i]=1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> father[x]==x ? x : (father[x]=<span class="built_in">find</span>(father[x]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        father[y]=<span class="built_in">find</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;cin&gt;&gt;N;</span><br><span class="line">    <span class="function">DisjointSet <span class="title">T</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="type">bool</span> energy[<span class="number">101</span>][<span class="number">101</span>]=&#123;&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> M;cin&gt;&gt;M;</span><br><span class="line">    <span class="type">int</span> K;cin&gt;&gt;K;</span><br><span class="line">    <span class="type">int</span> temp1,temp2,rope;</span><br><span class="line">    <span class="keyword">while</span>(M--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;temp1&gt;&gt;temp2&gt;&gt;rope;</span><br><span class="line">        <span class="keyword">if</span>(rope==<span class="number">1</span>)</span><br><span class="line">            T.<span class="built_in">merge</span>(temp1,temp2);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(rope==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            energy[temp1][temp2]=<span class="literal">true</span>;</span><br><span class="line">            energy[temp2][temp1]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(K--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> is_friend=<span class="literal">false</span>,is_energy=<span class="literal">false</span>;</span><br><span class="line">        cin&gt;&gt;temp1&gt;&gt;temp2;</span><br><span class="line">        <span class="keyword">if</span>(T.<span class="built_in">find</span>(temp1)==T.<span class="built_in">find</span>(temp2))</span><br><span class="line">            is_friend=<span class="literal">true</span>;</span><br><span class="line">        is_energy=energy[temp1][temp2];</span><br><span class="line">        <span class="keyword">if</span>(is_friend)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(is_energy)</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;OK but...&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;No problem&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(is_energy)</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;No way&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;OK&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本代码<strong>并未</strong>用到<strong>按秩排序</strong>，数据量小为原因之一，之二则是因为本人认为按秩排序并不符合逻辑，在代码的运行过程中由于<strong>路径压缩</strong>的存在，<strong>秩</strong>会变得非常混乱，完全没必要使用了，可能在足够大的数据量中才有一定的用武之地。</p><h2 id="并查集（Disjoint-Set）"><a href="#并查集（Disjoint-Set）" class="headerlink" title="并查集（Disjoint Set）"></a>并查集（Disjoint Set）</h2><p>并查集被很多OIer认为是最简洁而优雅的数据结构之一，主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p><ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li></ul><h5 id="一、概念及其介绍"><a href="#一、概念及其介绍" class="headerlink" title="一、概念及其介绍"></a>一、概念及其介绍</h5><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。</p><p>并查集的思想是用一个数组表示了整片森林（parent），树的根节点唯一标识了一个集合，我们只要找到了某个元素的的树根，就能确定它在哪个集合里。</p><h5 id="二、适用说明"><a href="#二、适用说明" class="headerlink" title="二、适用说明"></a>二、适用说明</h5><p>并查集用在一些有 <strong>N</strong> 个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这个过程看似并不复杂，但数据量极大，若用其他的数据结构来描述的话，往往在空间上过大，计算机无法承受，也无法在短时间内计算出结果，所以只能用并查集来处理。</p><h5 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h5><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有编号为1, 2, 3, …, n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。</p><h6 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> find(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p><h6 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    fa[find(i)] = find(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者，这里暂时不重要。本文末尾会给出一个更合理的比较方法。</p><h5 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h5><p>显而易见，这种简单的方法几乎不对树进行维护，极有可能造成树变成链，复杂度直线上升的惨剧。那么如何进行维护呢？既然我们在进行查询的时候会进行递归，不如在这个递归的过程中直接把沿途节点的父节点都设置为根节点。</p><h6 id="合并（路径压缩）"><a href="#合并（路径压缩）" class="headerlink" title="合并（路径压缩）"></a>合并（路径压缩）</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = find(fa[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];         <span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码常常简写为一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意赋值运算符=的优先级没有三元运算符?:高，这里要加括号。</p><p>路径压缩优化后，并查集的时间复杂度已经比较低了，绝大多数不相交集合的合并查询问题都能够解决。然而，对于某些时间卡得很紧的题目，我们还可以进一步优化。</p><h6 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h6><p>有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个<strong>菊花图</strong>（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。例如，现在我们有一棵较复杂的树需要与一个单元素的集合合并：</p><p>我们应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。</p><p>我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank（<strong>秩</strong>）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p><p>路径压缩和按秩合并如果一起使用，时间复杂度接近 O(n) ，但是很可能会破坏rank的准确性。</p><p><strong>初始化（按秩合并）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>合并（按秩合并）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = find(i), y = find(j);    <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;                   <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://www.lymone.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="数据结构" scheme="http://www.lymone.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="PTA" scheme="http://www.lymone.cc/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>ACM学习路线</title>
    <link href="http://www.lymone.cc/p/605add1b.html"/>
    <id>http://www.lymone.cc/p/605add1b.html</id>
    <published>2022-10-02T12:23:44.000Z</published>
    <updated>2023-03-03T13:04:08.328Z</updated>
    
    <content type="html"><![CDATA[<p>到处扒拉，找到的一个看起来合理的学习路线，保存一下</p><span id="more"></span><p>1.学好专业课知识：理解数据库原理、优化，计算机组成原理，概率论，线性代数，操作系统，C/C++ ,高等数学，数据结构，算法，离散数学，网络协议，socket编程 ，编译原理，软件工程，设计模式，linux服务器搭建。脚本编程。STL源码分析，多线程编程。</p><p>1.c基础语法必须全部学完<br>2.简单数学题：求最大公约数，筛选求素数，康托展开，同余定理，次方求模，<br>3.计算几何初步（三角形面积，三点顺序）<br>4.简单的计算程序时间复杂度和空间复杂度。<br>5.二分查找，贪心算法经典算法<br>6.简单排序算法（冒泡，插入等）<br>7.高等数学，操作系统应用（dos命令，编辑注册表，使用组策略管理器管理组策略）。</p><p>1.c++语法：引用类型,函数重载类。<br>2.学会使用栈与队列等线性存储结构<br>3.掌握BFS和DFS以及树的前序，中序，后续遍历 4学会分治策略<br>5.冒泡排序，选择排序，插入排序，归并排序，快排，基数排序。<br>6.动态规划：最大字串和，最长公共子序列，最长单调递增子序列，01背包，完全背包等。<br>7.数论：扩展欧几里德算法，求逆元，同余方程，中国剩余定理。<br>8.博弈论：博弈问题与SG函数的定义，多个博弈问题SG值的合并。<br>9.使用c++ 网络编程与多线程编程<br>10.高等数学，线性代数（推荐做几道“矩阵运算”分类的题目）<br>11.网页设计 （html5+css+js）,php。</p><p>1.掌握C++语法，熟练使用STL<br>2.实现STL的一些基本容器和函数，使自己基本能看懂STL源码。<br>3.数据结构 （字典树），并查集，树状数组，简单线性树<br>4.图论：dijkstra/prim,单源最短路径之SPPA，差分约束系统，多源多点最短路径之FloydWarshall算法，求欧拉路（圆套圆算法）<br>5.拓扑排序，复杂BFS ，DFS搜索，复杂模拟题训练。<br>6.动态规划：多重背包，分组背包，依赖背包等各种背包问题，（背包九讲）<br>7.计算几何：判断点是否在线段上，线段相交，圆与矩形关系，点是否在多边形 内，点到线段的最近点，多边形面积，求多边形重心，求凸包，点在任意多边形内外的判定.<br>8.学习c++ 连接数据库，学习Qt</p><p>1.数据结构：单调队列，堆，并查集，树状数组，哈希表，线段树，LCA与RMQ的转化，后缀树，字典树，KMP算法，AC自动机理论与实现。<br>2.图论一：强连通分量，双连通分量（求割点，桥）强连通分量与双连通分量缩点，二分图匹配（二分图最大匹配，最小点集覆盖 最小路径覆盖，二分图最优匹配，二分图多重匹配，）网络流（最大流的sap,最大流的ISAP或者dinic等高效算法，最小费用最大流，最大流最小割定理，网络流的各种构图训练，最小割与最小点权覆盖等关系，次小生成树，第k短路，最小比率生成树。<br>3.动态规划： 斜率优化，四边形优化动态规划，树形动态规划，状态压缩动态规划，多做动态规划难题，训练思维，动态规划更高级进阶 。<br>4.数论和组合数学：高斯消元法，积性函数的应用，欧拉定理，费马小定理，威乐逊定理，群论基础，polya定理与计数问题，catalan数。<br>5.计算几何：多边形间踵点对，凸多边形间踵点对，四边形剖分，三角形剖分,凸多边形最小周长外接矩形，凸多边形最小面积外接矩形，凸多边形间最小距离，凸多边形直径，最小覆盖圆，定圆最大点集覆盖，平面上最近点对，三维计算几何算法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到处扒拉，找到的一个看起来合理的学习路线，保存一下&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://www.lymone.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="ACM" scheme="http://www.lymone.cc/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>配置VSCode遇到的问题</title>
    <link href="http://www.lymone.cc/p/4f108e10.html"/>
    <id>http://www.lymone.cc/p/4f108e10.html</id>
    <published>2022-09-30T10:33:48.000Z</published>
    <updated>2023-03-03T13:04:08.333Z</updated>
    
    <content type="html"><![CDATA[<p>在VSCode配置C++编译环境，遇到了报错：</p><blockquote><p>[window title] visual studio code [content] launch: program ‘输入程序名称，例如 d:\gitcode\lymonetest\vscodecode\a.exe’ does not exist [打开“launch.json”] [取消]</p></blockquote><p>反复操作无法解决，最后通过重启VSCode解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在VSCode配置C++编译环境，遇到了报错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[window title] visual studio code [content] launch: program ‘输入程序名称，例如 d:\gitcode\lymonetest\</summary>
      
    
    
    
    <category term="报错" scheme="http://www.lymone.cc/categories/%E6%8A%A5%E9%94%99/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="VSCode" scheme="http://www.lymone.cc/tags/VSCode/"/>
    
    <category term="IDE" scheme="http://www.lymone.cc/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>C++泛型编程学习</title>
    <link href="http://www.lymone.cc/p/a83b63e7.html"/>
    <id>http://www.lymone.cc/p/a83b63e7.html</id>
    <published>2022-09-30T03:33:17.000Z</published>
    <updated>2023-03-03T13:04:08.330Z</updated>
    
    <content type="html"><![CDATA[<p>看学长用STL，馋疯了。</p><p>22.12.1 我又来继续学了</p><span id="more"></span><h1 id="预备知识：模板"><a href="#预备知识：模板" class="headerlink" title="预备知识：模板"></a>预备知识：模板</h1><p>为了提高代码的重用性，C++中引入了泛型编程的概念，泛型编程的基础就是模板。</p><h2 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">( T a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 T可任意更换，typename 可换为 class</p><p>在调用的时候，必须给模板函数确定的数据类型</p><p>分为自动推断和明确给出两种</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动推断</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">func</span>(a);</span><br><span class="line"><span class="comment">//给出</span></span><br><span class="line"><span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(a);</span><br></pre></td></tr></table></figure><p>如此便实现了将数据类型作为函数的参数</p><h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mysort</span><span class="params">(T arry[],<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> xi=<span class="number">0</span>; xi&lt;len; xi++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> yi=<span class="number">0</span>; yi&lt;len; yi++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arry[xi]&gt;arry[yi])</span><br><span class="line">&#123;</span><br><span class="line">T c;</span><br><span class="line">c=arry[xi],arry[xi]=arry[yi],arry[yi]=c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> xi=<span class="number">0</span>; xi&lt;len; xi++)</span><br><span class="line">cout&lt;&lt;arry[xi]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arryint[]= &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> arrychar[]=<span class="string">&quot;ILOVEYOU&quot;</span>;</span><br><span class="line"><span class="type">int</span> len1=<span class="built_in">sizeof</span>(arryint)/<span class="built_in">sizeof</span>(<span class="type">int</span>)</span><br><span class="line">         ,len2=<span class="built_in">sizeof</span>(arrychar)/<span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line"><span class="built_in">mysort</span>(arryint,len1);</span><br><span class="line"><span class="built_in">mysort</span>(arrychar,len2);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="关于调用函数时参数发生的类型转换"><a href="#关于调用函数时参数发生的类型转换" class="headerlink" title="关于调用函数时参数发生的类型转换"></a>关于调用函数时参数发生的类型转换</h4><ul><li><p>调用函数模板，使用自动推导时，不会发生隐式类型转换</p></li><li><p>调用函数模板，显式指定类型，可以发生隐式类型转换</p></li></ul><h4 id="关于函数重载的调用规则"><a href="#关于函数重载的调用规则" class="headerlink" title="关于函数重载的调用规则"></a>关于函数重载的调用规则</h4><ol><li><p>如果函数模板和普通函数都可以实现，优先调用普通函数</p></li><li><p>可以通过空模板参数列表来强制调用函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func&lt;&gt;(a);</span><br></pre></td></tr></table></figure></li><li><p>函数模板可以发生重载</p></li><li><p>如果函数模板可以产生更好的匹配，优先调用函数模板</p></li></ol><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="一、vector"><a href="#一、vector" class="headerlink" title="一、vector"></a>一、vector</h2><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://wyqz.top/p/870124582.html">C++ STL总结 | 行码棋 (wyqz.top)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看学长用STL，馋疯了。&lt;/p&gt;
&lt;p&gt;22.12.1 我又来继续学了&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="泛型编程" scheme="http://www.lymone.cc/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
    <category term="STL" scheme="http://www.lymone.cc/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++贪吃蛇项目</title>
    <link href="http://www.lymone.cc/p/9309cfd8.html"/>
    <id>http://www.lymone.cc/p/9309cfd8.html</id>
    <published>2022-08-25T02:20:00.000Z</published>
    <updated>2023-03-03T13:04:08.331Z</updated>
    
    <content type="html"><![CDATA[<p>为了提高我的编程水平。在一众前辈的指引下，决定做个小项目，在完善项目的过程中逐渐提高自己的水准。</p><p>最终决定做个贪吃蛇小游戏吧，规则并不复杂，似乎和我的水平很搭。</p><p>本文提及的代码都可以在我(LymoneLM)的github仓库LymoneTest中找到。</p><span id="more"></span><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>首先敲定了使用的图形库为EasyX（当然主要也是因为目前EasyX也半生不熟）</p><h2 id="浅浅的写写画画"><a href="#浅浅的写写画画" class="headerlink" title="浅浅的写写画画"></a>浅浅的写写画画</h2><p>（Hexo挂图有点麻烦啊）</p><p><img src="https://s1.328888.xyz/2022/09/01/kmyTy.png" alt="OneNote绘制的思维导图"></p><p>打开OneNote，按照过去玩过的游戏，和对游戏工业的简单了解，初步的划分了编程的思路，大体的用已知的知识进行了构思。</p><h2 id="技术验证"><a href="#技术验证" class="headerlink" title="技术验证"></a>技术验证</h2><p>数据部分，地图方面准备使用一个字符型二维数组进行记录，初定大小为20*20。</p><p>蛇身则准备使用一个链队列进行存储，单进单出的蛇身节点和队列非常的相似。</p><h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p>我在数据结构方面的知识基本脱胎于程杰的《大话数据结构》，但是由于这本书主要是在高中的课余时间进行阅读的，所以并没有进行大量的实践，因此也出现了不小的岔子。</p><p>对于链队列，我最早的想法是使用struct结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> x,y;</span><br><span class="line">sNode *next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下为使用</span></span><br><span class="line">sNode *p=<span class="keyword">new</span> sNode;</span><br></pre></td></tr></table></figure><p>然而这里出现了问题，如果是链队列，肯定需要循环申请内存，然而如果不为p指针释放内存无法再次申请。</p><p>于是我改用了类</p><p>关于链队列的部分可以参看  C++进阶学习 那篇博文的有关内容，这里仅放出最后的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">sNode* snext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linkqueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//链队列-逆</span></span><br><span class="line"><span class="comment">//删尾加头 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQ</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enQ</span><span class="params">(sNode)</span></span>;</span><br><span class="line"><span class="function">sNode <span class="title">deQ</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryQ</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printQ</span><span class="params">()</span></span>;<span class="comment">//devOnly </span></span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">countQ</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pmapQ</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">sNode* front;</span><br><span class="line">sNode* rear;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体的实现参看SnakeData.cpp部分的文件</p><p>实际在实现的过程中参考了部分博文，但是原博文在实现程序的时候先创建了一个链队列类的对象作为链队列，并另外创建了一个对象，专门使用第二个对象的方法对链队列进行操作。</p><p>他的实现代码中所有的方法都含有一个引用传递的参数，传递一个该类的对象。我不知道这样做有什么好处，并且我在逻辑上也看不出这么做的优势，所以我并没有才用这个方法。</p><p>如果您了解我采用的方法的劣势或者明白他的这种实现的优势，恳请您能赐教。</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>绘制这部分总体来说问题并不大，参照帮助文档一步步的进行实现就好了。栅格绘制和简单图形绘制并没有任何问题，出现问题的是右边的文字绘制，在绘制过程中不断的发生报错，最后了解到这种绘制方式传入的字符串参数必须为TCHAR类型，终于通过改编例程中的代码实现了这个绘制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSD::drawdeath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">settextcolor</span>(<span class="number">0x0000FF</span>);</span><br><span class="line">    <span class="built_in">settextstyle</span>(<span class="number">40</span>, <span class="number">40</span>, <span class="string">L&quot;Minecraft&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;WASTED\n&quot;</span>);</span><br><span class="line">    RECT r = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">699</span>, <span class="number">504</span> &#125;;</span><br><span class="line">    <span class="built_in">drawtext</span>(_T(<span class="string">&quot;WASTED&quot;</span>), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSD::drawTitle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">settextcolor</span>(<span class="number">0xFFFFFF</span>);</span><br><span class="line">    <span class="built_in">settextstyle</span>(<span class="number">14</span>, <span class="number">14</span>, <span class="string">L&quot;Minecraft&quot;</span>);</span><br><span class="line">    RECT r = &#123; <span class="number">500</span>, <span class="number">10</span>, <span class="number">699</span>, <span class="number">30</span> &#125;;</span><br><span class="line">    <span class="built_in">drawtext</span>(_T(<span class="string">&quot;LymoneSnake&quot;</span>), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    r = &#123; <span class="number">500</span>, <span class="number">30</span>, <span class="number">699</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">drawtext</span>(_T(<span class="string">&quot;按↑↓←→开始&quot;</span>), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    <span class="built_in">settextstyle</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="string">L&quot;Minecraft&quot;</span>);</span><br><span class="line">    r = &#123; <span class="number">500</span>, <span class="number">50</span>, <span class="number">699</span>, <span class="number">90</span> &#125;;</span><br><span class="line">    <span class="built_in">drawtext</span>(_T(<span class="string">&quot;当前分数：&quot;</span>), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSD::drawScore</span><span class="params">(<span class="type">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR s[<span class="number">5</span>];</span><br><span class="line">    _stprintf_s(s, _T(<span class="string">&quot;%d&quot;</span>), score);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">settextcolor</span>(<span class="number">0xFFFFFF</span>);</span><br><span class="line">    <span class="built_in">settextstyle</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="string">L&quot;Minecraft&quot;</span>);</span><br><span class="line">    RECT r = &#123; <span class="number">500</span>, <span class="number">90</span>, <span class="number">699</span>, <span class="number">140</span> &#125;;</span><br><span class="line">    <span class="built_in">drawtext</span>(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Minecraft为使用的一个字体，理论上换用其他例如“黑体”是可以正常运行的。</p><h1 id="一些迭代"><a href="#一些迭代" class="headerlink" title="一些迭代"></a>一些迭代</h1><h2 id="画面绘制"><a href="#画面绘制" class="headerlink" title="画面绘制"></a>画面绘制</h2><p>最初的版本中，蛇每次移动后我都会重新绘制整个地图：</p><p>刷新map，绘制栅格，然后绘制蛇体</p><p>显而易见的，这会造成卡顿和频闪</p><p>在意识到这个问题之后我对链队列的实现进行了改进，在删除一个节点的同时返回这个节点的坐标，以此将这个坐标对应的位置画上一个黑色的图形，从而实现缩短蛇体。</p><p>这种方案显然更合适。</p><p>其实在采用这种绘制方式之后，map这个二维字符数组的作用就有点鸡肋了，但是随机苹果和蛇头的功能仍然依赖这个东西，后续我想添加的墙体功能也可能依赖于这个map，所以并没有对其进行彻底删除。</p><h2 id="蛇头"><a href="#蛇头" class="headerlink" title="蛇头"></a>蛇头</h2><p>作为判定的关键，蛇头的坐标显而易见的十分重要，在最初的版本中我使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> hx, hy</span><br></pre></td></tr></table></figure><p>来存储蛇头的坐标，显然这样做并不直观，所以随后我改用一个sNode对其进行存储。</p><h2 id="退出机制"><a href="#退出机制" class="headerlink" title="退出机制"></a>退出机制</h2><p>其实在任何时候按下ESC是可以退出的，这是在我不断调试的过程中加入的一个功能。完全没有在程序的界面中进行提示。</p><h2 id="主循环中的延迟"><a href="#主循环中的延迟" class="headerlink" title="主循环中的延迟"></a>主循环中的延迟</h2><p>这个是在调试的过程中更改最多的地方</p><p>起初我让检测输入的部分循环多次，后来发现因为消息函数的问题，其实这样做会花费大量的时间，导致等待时间非常的长，后来改为很少次数的输入判断，其实这样是够用的，因为键盘输入会保留在队列中等待处理。</p><p>早期测试中蛇非常难以操作，你必须进行预判才能正常游戏，显然这并不是正常的玩法。经过考量我才发现（真是太傻了），其实在每次蛇移动完之后再加一个延迟，给玩家一个观察的时间，这个问题就能很完美的解决了。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>我不打算提供编译好的程序了（毕竟程序本身和编译并不复杂）</p><p>您可以直接在我的仓库clone源代码或者直接复制下文进行编译即可</p><p>（甚至可以直接改编成单文件进行编译）</p><h2 id="LymoneSnake-cpp"><a href="#LymoneSnake-cpp" class="headerlink" title="LymoneSnake.cpp"></a>LymoneSnake.cpp</h2><p>主程序文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;easyx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Snake.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> map[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="comment">/*Wall-Head-Apple-Snake*/</span></span><br><span class="line">ExMessage m;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Nextstep;</span><br><span class="line"><span class="comment">/*Up-Down-Left-Right*/</span></span><br><span class="line"><span class="type">int</span> times = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> delay = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> snakelength=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> xi = <span class="number">0</span>; xi &lt; <span class="number">20</span>; xi++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> yi = <span class="number">0</span>; yi &lt; <span class="number">20</span>; yi++)</span><br><span class="line">        &#123;</span><br><span class="line">            map[xi][yi] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//block 25*25</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consolLoaded</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;==ConsolLoaded==\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG  </span></span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*==初始化==*/</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">initgraph</span>(<span class="number">700</span>, <span class="number">505</span>, EW_SHOWCONSOLE);</span><br><span class="line">    <span class="built_in">consolLoaded</span>();</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">initgraph</span>(<span class="number">700</span>, <span class="number">505</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line">    LSD::<span class="built_in">drawNet</span>();</span><br><span class="line">    LSD::<span class="built_in">drawTitle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG_TESTDATA</span></span><br><span class="line">    <span class="built_in">testData</span>();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG_TESTDATA</span></span></span><br><span class="line">    LSC::<span class="built_in">initrand</span>();</span><br><span class="line">    LSC::<span class="built_in">randhead</span>();</span><br><span class="line">    LSC::<span class="built_in">randapple</span>();</span><br><span class="line">    LSD::<span class="built_in">drawMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*开始*/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//输入检定</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (LSC::<span class="built_in">directionCheck</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, Nextstep);</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//死亡检定</span></span><br><span class="line">        <span class="keyword">if</span> (LSC::<span class="built_in">deathCheck</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            LSD::<span class="built_in">drawdeath</span>();</span><br><span class="line">            m = <span class="built_in">getmessage</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//移动</span></span><br><span class="line">            LSC::<span class="built_in">lengthCheck</span>();</span><br><span class="line">            LSD::<span class="built_in">drawScore</span>(snakelength);</span><br><span class="line">            <span class="comment">//cleardevice();</span></span><br><span class="line">            <span class="comment">//LSD::drawNet();</span></span><br><span class="line">            LSD::<span class="built_in">drawMap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Sleep</span>(delay*times);</span><br><span class="line">    &#125;<span class="comment">//main while</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">closegraph</span>();<span class="comment">//关闭绘图窗口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//testdata devonly</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TestDataLoading\n&quot;</span>);</span><br><span class="line">    map[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">    map[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">    map[<span class="number">3</span>][<span class="number">3</span>] = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">    map[<span class="number">4</span>][<span class="number">4</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">    map[<span class="number">5</span>][<span class="number">5</span>] = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">    map[<span class="number">6</span>][<span class="number">6</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">    map[<span class="number">7</span>][<span class="number">7</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    map[<span class="number">8</span>][<span class="number">8</span>] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    map[<span class="number">9</span>][<span class="number">9</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    map[<span class="number">10</span>][<span class="number">10</span>] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Snake-h"><a href="#Snake-h" class="headerlink" title="Snake.h"></a>Snake.h</h2><p>头文件，各种声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="comment">//#define DEBUG_TESTDATA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SNAKEDRAW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNAKEDRAW_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LSD</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*棋盘绘制*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawNet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawMap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanmap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*文字绘制*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawTitle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawScore</span><span class="params">(<span class="type">int</span> score)</span></span>;</span><br><span class="line"><span class="comment">/*特殊画面*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawdeath</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SNAKECHECK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNAKECHECK_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LSC</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*Random*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initrand</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initrand</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randapple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randhead</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*Check*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initwall</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">directionCheck</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deathCheck</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCheck</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SNAKEDATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNAKEDATA_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">sNode* snext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linkqueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//链队列-逆</span></span><br><span class="line"><span class="comment">//删尾加头 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initQ</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enQ</span><span class="params">(sNode)</span></span>;</span><br><span class="line"><span class="function">sNode <span class="title">deQ</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryQ</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printQ</span><span class="params">()</span></span>;<span class="comment">//devOnly </span></span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">countQ</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pmapQ</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">sNode* front;</span><br><span class="line">sNode* rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="SnakeCheck-cpp"><a href="#SnakeCheck-cpp" class="headerlink" title="SnakeCheck.cpp"></a>SnakeCheck.cpp</h2><p>各种判定的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Check Frame</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;EasyX.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Snake.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> map[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">extern</span> ExMessage m;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> Nextstep;</span><br><span class="line">sNode Head,Rear;</span><br><span class="line"><span class="comment">//extern int Head.x, Head.y;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> snakelength;</span><br><span class="line">Linkqueue Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSC::initwall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 墙体检入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSC::initrand</span><span class="params">(<span class="type">int</span> seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(seed);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSC::initrand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSC::randapple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">short</span> xi, yi;</span><br><span class="line">loop:</span><br><span class="line">xi = <span class="built_in">rand</span>() % <span class="number">20</span>;</span><br><span class="line">yi = <span class="built_in">rand</span>() % <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (map[xi][yi] == <span class="number">0</span>)</span><br><span class="line">map[xi][yi] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">goto</span> loop;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSC::randhead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.<span class="built_in">initQ</span>();</span><br><span class="line"><span class="type">short</span> xi, yi;</span><br><span class="line">loop:</span><br><span class="line">xi = <span class="built_in">rand</span>() % <span class="number">20</span>;</span><br><span class="line">yi = <span class="built_in">rand</span>() % <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (map[xi][yi] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">map[xi][yi] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">Head.x = xi;Head.y = yi;</span><br><span class="line">Q.<span class="built_in">enQ</span>(Head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">goto</span> loop;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*键盘输入*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LSC::directionCheck</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">peekmessage</span>(&amp;m, EM_KEY))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (m.message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line"><span class="keyword">if</span> (m.vkcode == VK_UP)</span><br><span class="line">&#123;</span><br><span class="line">Nextstep = <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m.vkcode == VK_DOWN)</span><br><span class="line">&#123;</span><br><span class="line">Nextstep = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m.vkcode == VK_LEFT)</span><br><span class="line">&#123;</span><br><span class="line">Nextstep = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m.vkcode == VK_RIGHT)</span><br><span class="line">&#123;</span><br><span class="line">Nextstep = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m.vkcode == VK_ESCAPE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LSC::deathCheck</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (Nextstep)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (Head.y - <span class="number">1</span> &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[Head.x][Head.y - <span class="number">1</span>] != <span class="number">0</span>&amp;&amp; map[Head.x][Head.y - <span class="number">1</span>] != <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (Head.y + <span class="number">1</span> &gt;= <span class="number">20</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[Head.x][Head.y + <span class="number">1</span>] != <span class="number">0</span>&amp;&amp; map[Head.x][Head.y + <span class="number">1</span>] != <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (Head.x - <span class="number">1</span> &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[Head.x - <span class="number">1</span>][Head.y] != <span class="number">0</span>&amp;&amp; map[Head.x - <span class="number">1</span>][Head.y] != <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (Head.x + <span class="number">1</span> &gt;= <span class="number">20</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (map[Head.x + <span class="number">1</span>][Head.y] != <span class="number">0</span>&amp;&amp; map[Head.x + <span class="number">1</span>][Head.y] != <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error:UndefinedDeathCheck\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LSC::lengthCheck</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> isA=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//苹果检定并移动</span></span><br><span class="line"><span class="keyword">switch</span> (Nextstep)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (map[Head.x][--Head.y] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">isA = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (map[Head.x][++Head.y] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">isA = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (map[--Head.x][Head.y] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">isA = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (map[++Head.x][Head.y] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">isA = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error:UndefinedLengthCheck\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isA)</span><br><span class="line">&#123;</span><br><span class="line">snakelength++;</span><br><span class="line">LSC::<span class="built_in">randapple</span>();</span><br><span class="line">&#125;</span><br><span class="line">Q.<span class="built_in">enQ</span>(Head);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//长度检定</span></span><br><span class="line"><span class="type">int</span> length = Q.<span class="built_in">countQ</span>();</span><br><span class="line"><span class="keyword">if</span> (length &gt; snakelength)</span><br><span class="line">&#123;</span><br><span class="line">Rear=Q.<span class="built_in">deQ</span>();</span><br><span class="line"><span class="built_in">setfillcolor</span>(<span class="number">0x000000</span>);</span><br><span class="line"><span class="built_in">setlinecolor</span>(<span class="number">0x000000</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, Rear.x, Rear.y);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"><span class="built_in">fillcircle</span>(<span class="number">25</span>*Rear.x + <span class="number">13</span>, <span class="number">25</span>*Rear.y + <span class="number">13</span>, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">Q.<span class="built_in">pmapQ</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SnakeData-cpp"><a href="#SnakeData-cpp" class="headerlink" title="SnakeData.cpp"></a>SnakeData.cpp</h2><p>蛇体数据结构的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Snake.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> map[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Linkqueue::initQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sNode* p = <span class="keyword">new</span> sNode;</span><br><span class="line">front = p;</span><br><span class="line">rear = p;</span><br><span class="line">p-&gt;snext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Linkqueue::enQ</span><span class="params">(sNode node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sNode* p = <span class="keyword">new</span> sNode;</span><br><span class="line">p-&gt;x = node.x;</span><br><span class="line">p-&gt;y = node.y;</span><br><span class="line">rear-&gt;snext = p;</span><br><span class="line">rear = p;</span><br><span class="line">p-&gt;x = node.x;</span><br><span class="line">p-&gt;y = node.y;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sNode <span class="title">Linkqueue::deQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sNode rearNode;</span><br><span class="line"><span class="keyword">if</span> (rear == front)</span><br><span class="line">&#123;</span><br><span class="line">rearNode.x = <span class="number">-1</span>;</span><br><span class="line">rearNode.y = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sNode* p;</span><br><span class="line">p = front-&gt;snext;</span><br><span class="line">front-&gt;snext = p-&gt;snext;</span><br><span class="line">rearNode.x = p-&gt;x;</span><br><span class="line">rearNode.y = p-&gt;y;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> rearNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Linkqueue::destoryQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (rear != front)</span><br><span class="line">Linkqueue::<span class="built_in">deQ</span>();</span><br><span class="line"><span class="keyword">delete</span> front;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Linkqueue::printQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rear == front)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">sNode* p = front;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;snext;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;X=&quot; &lt;&lt; p-&gt;x &lt;&lt; &quot;Y=&quot; &lt;&lt; p-&gt;y &lt;&lt; std::endl;</span></span><br><span class="line">&#125; <span class="keyword">while</span> (p != rear);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">Linkqueue::countQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rear == front)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">short</span> num = <span class="number">0</span>;</span><br><span class="line">sNode* p = front;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;snext;</span><br><span class="line">++num;</span><br><span class="line">&#125; <span class="keyword">while</span> (p != rear);</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Linkqueue::pmapQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rear == front)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LSD::<span class="built_in">cleanmap</span>();</span><br><span class="line">sNode* p = front;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;snext;</span><br><span class="line">map[p-&gt;x][p-&gt;y] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (p != rear);</span><br><span class="line">map[p-&gt;x][p-&gt;y] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SnakeDraw-cpp"><a href="#SnakeDraw-cpp" class="headerlink" title="SnakeDraw.cpp"></a>SnakeDraw.cpp</h2><p>绘制部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Draw Frame</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;easyx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Snake.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> map[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSD::drawNet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PrintNet\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setlinecolor</span>(<span class="number">0xFFFFFF</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        <span class="built_in">line</span>(<span class="number">25</span> * i, <span class="number">0</span>, <span class="number">25</span> * i, <span class="number">500</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        <span class="built_in">line</span>(<span class="number">0</span>, <span class="number">25</span> * i, <span class="number">500</span>, <span class="number">25</span> * i);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSD::drawMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PrintMap\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> xi = <span class="number">0</span>; xi &lt; <span class="number">20</span>; xi++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> yi = <span class="number">0</span>; yi &lt; <span class="number">20</span>; yi++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">short</span> x = <span class="number">25</span> * xi, y = <span class="number">25</span> * yi;</span><br><span class="line">            <span class="keyword">switch</span> (map[xi][yi])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                <span class="built_in">setfillcolor</span>(<span class="number">0x2a2aa5</span>);</span><br><span class="line">                <span class="built_in">setlinecolor</span>(<span class="number">0x2a2aa5</span>);</span><br><span class="line">                <span class="built_in">fillrectangle</span>(x + <span class="number">1</span>, y + <span class="number">1</span>, x + <span class="number">24</span>, y + <span class="number">24</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">                <span class="built_in">setfillcolor</span>(<span class="number">0x0000ff</span>);</span><br><span class="line">                <span class="built_in">setlinecolor</span>(<span class="number">0x0000ff</span>);</span><br><span class="line">                <span class="built_in">fillcircle</span>(x + <span class="number">13</span>, y + <span class="number">13</span>, <span class="number">11</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                <span class="built_in">setfillcolor</span>(<span class="number">0xffffff</span>);</span><br><span class="line">                <span class="built_in">setlinecolor</span>(<span class="number">0xffffff</span>);</span><br><span class="line">                <span class="built_in">fillcircle</span>(x + <span class="number">13</span>, y + <span class="number">13</span>, <span class="number">11</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                <span class="built_in">setfillcolor</span>(<span class="number">0x6600aa</span>);</span><br><span class="line">                <span class="built_in">setlinecolor</span>(<span class="number">0x00ff00</span>);</span><br><span class="line">                <span class="built_in">fillcircle</span>(x + <span class="number">13</span>, y + <span class="number">13</span>, <span class="number">11</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cleardevice();//清空绘版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSD::cleanmap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> xi = <span class="number">0</span>; xi &lt; <span class="number">20</span>; xi++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> yi = <span class="number">0</span>; yi &lt; <span class="number">20</span>; yi++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[xi][yi] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                map[xi][yi] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (map[xi][yi] == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">                map[xi][yi] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSD::drawdeath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">settextcolor</span>(<span class="number">0x0000FF</span>);</span><br><span class="line">    <span class="built_in">settextstyle</span>(<span class="number">40</span>, <span class="number">40</span>, <span class="string">L&quot;Minecraft&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;WASTED\n&quot;</span>);</span><br><span class="line">    RECT r = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">699</span>, <span class="number">504</span> &#125;;</span><br><span class="line">    <span class="built_in">drawtext</span>(_T(<span class="string">&quot;WASTED&quot;</span>), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSD::drawTitle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">settextcolor</span>(<span class="number">0xFFFFFF</span>);</span><br><span class="line">    <span class="built_in">settextstyle</span>(<span class="number">14</span>, <span class="number">14</span>, <span class="string">L&quot;Minecraft&quot;</span>);</span><br><span class="line">    RECT r = &#123; <span class="number">500</span>, <span class="number">10</span>, <span class="number">699</span>, <span class="number">30</span> &#125;;</span><br><span class="line">    <span class="built_in">drawtext</span>(_T(<span class="string">&quot;LymoneSnake&quot;</span>), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    r = &#123; <span class="number">500</span>, <span class="number">30</span>, <span class="number">699</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">drawtext</span>(_T(<span class="string">&quot;按↑↓←→开始&quot;</span>), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    <span class="built_in">settextstyle</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="string">L&quot;Minecraft&quot;</span>);</span><br><span class="line">    r = &#123; <span class="number">500</span>, <span class="number">50</span>, <span class="number">699</span>, <span class="number">90</span> &#125;;</span><br><span class="line">    <span class="built_in">drawtext</span>(_T(<span class="string">&quot;当前分数：&quot;</span>), &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LSD::drawScore</span><span class="params">(<span class="type">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR s[<span class="number">5</span>];</span><br><span class="line">    _stprintf_s(s, _T(<span class="string">&quot;%d&quot;</span>), score);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">settextcolor</span>(<span class="number">0xFFFFFF</span>);</span><br><span class="line">    <span class="built_in">settextstyle</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="string">L&quot;Minecraft&quot;</span>);</span><br><span class="line">    RECT r = &#123; <span class="number">500</span>, <span class="number">90</span>, <span class="number">699</span>, <span class="number">140</span> &#125;;</span><br><span class="line">    <span class="built_in">drawtext</span>(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>其实这个东西在好久之前（大概半个月？）就已经实现了，在我的预想中，我想给它加入更好的UI，选关系统，内置地图，随机种子选择，Level选择，蛇的速度逐渐增加等等各种功能。</p><p>显而易见，到现在我并没有实现它。接下来可能会更忙，可能也没有时间去完成这件事了，所以说就先写完这篇搁置已久的博文吧。</p><p>如果有后续我可能会新开一篇博文，而不是对这篇博文进行重新编辑了。</p><p>不知道您是因为什么原因看到我这篇博文，虽然我确实写的很烂，但还是希望能对您产生一些帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了提高我的编程水平。在一众前辈的指引下，决定做个小项目，在完善项目的过程中逐渐提高自己的水准。&lt;/p&gt;
&lt;p&gt;最终决定做个贪吃蛇小游戏吧，规则并不复杂，似乎和我的水平很搭。&lt;/p&gt;
&lt;p&gt;本文提及的代码都可以在我(LymoneLM)的github仓库LymoneTest中找到。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
    <category term="EasyX" scheme="http://www.lymone.cc/tags/EasyX/"/>
    
  </entry>
  
  <entry>
    <title>Python入门</title>
    <link href="http://www.lymone.cc/p/d9ef328.html"/>
    <id>http://www.lymone.cc/p/d9ef328.html</id>
    <published>2022-08-22T08:56:10.000Z</published>
    <updated>2023-05-03T04:31:37.034Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个预留的博客，主要是为了验证重新部署的hexo是否正常，同时预留作接下来python学习的记录</p><p>已经更新正式内容</p><span id="more"></span><p>22.11.4因为想要偷懒做安全教育题目，开始学py</p><p>知识结构来自：</p><p>Bilibili@黑马程序员</p><p>Python语言程序设计微课视频版.清华大学出版社.孙晋飞</p><hr><p>part1</p><h1 id="黑马"><a href="#黑马" class="headerlink" title="黑马"></a>黑马</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>在代码中，被<strong>写下来</strong>的固定的<strong>值</strong>，称之为字面量</p><h3 id="数字Number"><a href="#数字Number" class="headerlink" title="数字Number"></a>数字Number</h3><p>整形int</p><p>浮点float</p><p>复数complex 例如4+3j,以j结尾表示复数</p><p>布尔bool True(1),False(0);</p><h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><h3 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h3><p>有序的可变序列，可有序记录一堆数据</p><h3 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h3><p>有序不可变序列</p><h3 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h3><p>无序不重合集合</p><h3 id="字典Dictionary"><a href="#字典Dictionary" class="headerlink" title="字典Dictionary"></a>字典Dictionary</h3><p>无序Key-Value集合</p><h2 id="注释-或“”“-”“”"><a href="#注释-或“”“-”“”" class="headerlink" title="注释#或“”“+”“”"></a>注释#或“”“+”“”</h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>变量名 = 变量值</p><p>即可进行定义。Python无需定义变量类型。</p><p>（别瞎用分号）</p><p><strong>查看</strong>变量类型:type()</p><p><strong>Python中变量没有类型，变量存储的数据有类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line">A = <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure><p>这种操作在Python中合法</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>int(x)</p><p>float(x)</p><p>str(x)</p><p>字符串整形浮点数可以相互转换，但是字符串转其他两者需要保证字符串全为数字，且浮点转整形时存在精度丢失</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="三种定义方式"><a href="#三种定义方式" class="headerlink" title="三种定义方式"></a>三种定义方式</h4><ol><li>单引号‘A’:这种方法可以包含双引号</li><li>双引号”A”</li><li>三引号”“”A“”“</li></ol><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>“AAAA”<strong>+</strong>“BBBB”</p><p>变量，字面量的字符串之间可以拼接</p><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><p>占位符替换：</p><p>“Hello,%s” % “World!”</p><p>多个占位替换：</p><p>“hello %s world %s” % (“123”,”456”)</p><h5 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h5><p>%s字符串 %d整数 %f浮点型</p><h5 id="精度控制"><a href="#精度控制" class="headerlink" title="精度控制"></a>精度控制</h5><p>%.2f %7f等，与C/C++同</p><h4 id="快速格式化"><a href="#快速格式化" class="headerlink" title="快速格式化"></a>快速格式化</h4><p>通过语法:f内容{变量}”的格式来快速格式化</p><ol><li>不理会变量类型</li><li>不进行精度控制</li></ol><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>变量方法类名所用的名称</p><ul><li>内容限定：英文、中文、数字（不可以用在开头）、下划线_</li><li>大小写敏感</li><li>不可使用关键字</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p> +加</p><p>-减</p><p>*乘：可以返回字符串重复N次的结果</p><p>/除</p><p>//取整除</p><p>%取余</p><p>**指数</p><p>=赋值运算符</p><p><strong>算数运算符都有复合运算符</strong></p><h1 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h1><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>print(内容)</p><p>内容可以任意填入，字面量或者变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;anything&quot;,end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>使用这种方法输出可以使得输出不换行</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>input()</p><p>A = input()</p><p>括号内可以填入提示语句</p><p>input的输入全部为<strong>字符串</strong>类型，如果想要作为数字进行处理，需要自行<strong>转换</strong></p><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="逻辑判断符"><a href="#逻辑判断符" class="headerlink" title="逻辑判断符"></a>逻辑判断符</h3><p>与C/C++相同</p><p>==、&gt;=、&lt;=、!=、&gt;、&lt;</p><p>结果为布尔型（bool）值为True和False</p><p><strong>布尔值赋值给变量可以获得布尔值变量</strong></p><h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><h4 id="基本语句-1"><a href="#基本语句-1" class="headerlink" title="基本语句"></a>基本语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">执行语句</span><br><span class="line">其他语句</span><br></pre></td></tr></table></figure><p>依靠<strong>缩进</strong>来判断哪些语句在if内，哪些在if外</p><p>判断条件后面有个<strong>冒号</strong>，其本身无需打括号</p><h4 id="else分支"><a href="#else分支" class="headerlink" title="else分支"></a>else分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">执行语句</span><br><span class="line">else:</span><br><span class="line">执行语句2</span><br><span class="line">其他语句</span><br></pre></td></tr></table></figure><p>注意if与else<strong>同级</strong></p><p>缩进为四个空格</p><h4 id="elif分支"><a href="#elif分支" class="headerlink" title="elif分支"></a>elif分支</h4><p>elif与if、else同级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">elif 条件:</span><br><span class="line">执行语句N</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 条件:</span><br><span class="line">循环体</span><br></pre></td></tr></table></figure><p>条件为False时终止</p><p>随笔猜想：python中逻辑缩进前使用“：”？</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for 临时变量 in 待处理数据集:</span><br><span class="line">循环满足条件时执行的代码</span><br></pre></td></tr></table></figure><p>案例，依次打印</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;THIS IS A STR&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> name:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p><strong>待处理的数据集</strong>严格称呼应该为<strong>序列类型</strong>，包含 字符串 列表 元组 等</p><h4 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h4><p>可以获得一个简单的数字序列，可以配合for使用</p><p><code>range(num)</code>序列从0开始，到num结束，不含num本身</p><p><code>range(num1,num2)</code>由num1开始到num2结束，不含num2</p><p><code>range(num1,num2,step)</code>由num1到num2，步进step</p><h3 id="循环中断"><a href="#循环中断" class="headerlink" title="循环中断"></a>循环中断</h3><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>中断本次循环进入下次循环</p><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>结束本循环</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>典中典函数导入，鉴定为提高代码复用性</p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(传入参数)：</span><br><span class="line">函数体</span><br><span class="line">return 返回值</span><br></pre></td></tr></table></figure><h2 id="None类型"><a href="#None类型" class="headerlink" title="None类型"></a>None类型</h2><p>其实就是void啊</p><p>不写<code>return</code>与<code>return None</code>等价</p><p>None值逻辑上为False</p><h2 id="说明文档"><a href="#说明文档" class="headerlink" title="说明文档"></a>说明文档</h2><p>在函数体内三对引号内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    整体功能描述</span></span><br><span class="line"><span class="string">    :param x: 对于X的说明</span></span><br><span class="line"><span class="string">    :param y: 对于Y的说明 </span></span><br><span class="line"><span class="string">    :return: 返回值 </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><p>Part2</p><h1 id="Python语言程序设计"><a href="#Python语言程序设计" class="headerlink" title="Python语言程序设计"></a>Python语言程序设计</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一个预留的博客，主要是为了验证重新部署的hexo是否正常，同时预留作接下来python学习的记录&lt;/p&gt;
&lt;p&gt;已经更新正式内容&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="http://www.lymone.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>C++进阶学习</title>
    <link href="http://www.lymone.cc/p/a34e9209.html"/>
    <id>http://www.lymone.cc/p/a34e9209.html</id>
    <published>2022-07-16T02:13:57.000Z</published>
    <updated>2023-03-03T13:04:08.329Z</updated>
    
    <content type="html"><![CDATA[<p>之前的C++学习都是浅尝辄止，这一次直接购入《C++ Primer Plus》系统深入的学习一些C++的知识，尤其C++擅长的面向对象部分。</p><p>引用表在文章末尾</p><span id="more"></span><h1 id="union"><a href="#union" class="headerlink" title="union"></a>union</h1><p>union即为联合，它是一种特殊的类。通过关键字union进行定义，一个union可以有多个数据成员。<br>在任意时刻，联合中只能有一个数据成员可以有值。当给联合中某个成员赋值之后，该联合中的其它成员就变成未定义状态了。<br>在C/C++程序的编写中，当多个基本数据类型或复合<a href="https://so.csdn.net/so/search?q=数据结构&amp;spm=1001.2101.3001.7020">数据结构</a>要占用同一片内存时，我们要使用联合体；当多种类型，多个对象，多个事物只取其一时（我们姑且通俗地称其为“n 选1”），我们也可以使用联合体来发挥其长处。<br>union主要是共享<a href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>，分配内存以其最大的结构或对象为大小，即sizeof最大的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">myun</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> &#123; <span class="type">int</span> x; <span class="type">int</span> y; <span class="type">int</span> z; &#125;u; </span><br><span class="line"><span class="type">int</span> k; </span><br><span class="line">&#125;a; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">a.u.x =<span class="number">4</span>;</span><br><span class="line">a.u.y =<span class="number">5</span>; </span><br><span class="line">a.u.z =<span class="number">6</span>; </span><br><span class="line">a.k = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,a.u.x,a.u.y,a.u.z);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><p>由于union类型是共享内存，以size最大的结构作为自己的大小，这样的话，myun这个结构就包含u这个结构体，而大小也等于u这个结构体 的大小，在内存中的排列为声明的顺序x,y,z从低到高，然后赋值的时候，在内存中，就是x的位置放置4，y的位置放置5，z的位置放置6，现在对k赋 值，对k的赋值因为是union，要共享内存，所以从union的首地址开始放置，首地址开始的位置其实是x的位置，这样原来内存中x的位置就被k所赋的值代替了，就变为0了，这个时候要进行打印，就直接看内存里就行了，x的位置也就是k的位置是0，而y，z的位置的值没有改变，所以应该是0,5,6。</p><p>EasyX的ExMessage的定义就涉及到了union的使用，有兴趣可以看看我写的EasyX的博客。</p><h1 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h1><p>稍大点的项目一般就不会使用单文件编程。毕竟多文件的好处实在是多，例如模块开发、分工协作、代码复用、结构清晰、方便模块更新。</p><p>那么怎么使用C++进行多文件编程呢？最先要搞懂的就是C++程序的文件类型、</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>C++程序常用的文件有两大类</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>头文件常常以.h结尾，通常被用于放置各种声明，用于被主程序文件包含</p><blockquote><p>头文件的存在是为了联系多个源文件，是源文件之间的接口。C++与C一样，要求<strong>先声明后使用</strong>，可是编译的时候是单文件编译的。C++编译过程中C++把每个文件单独编译出来，再通过链接把编译出来的多个文件组成一个可执行程序。编译的时候只检查函数声明，只要该文件能在之前声明过函数就能编译成功。函数定义是在链接阶段检查的，而链接是多文件共同参与的。</p><p>但是，每次使用其它文件的函数前都要自己先声明显然很繁琐也容易出错。所以，我们把声明类语句放到一类文件里，称之“头文件”，如果你需要使用到某个函数，就把它所在的头文件包含进来，头文件的内容会在编译前被粘贴到源文件中，这样在编译的时候就能正常通过了。</p></blockquote><p>头文件的内容一般都会使用条件编译预处理语句包住，防止因为依赖关系多次被包含。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//header.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_H</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>既然知道头文件的作用，那哪些东西应该放在头文件？哪些不能放在头文件？很好理解，<strong>如果这部分需要复制给每个相关的cpp，就把它放在头文件，如果被多个cpp复制之后，可能导致它们在链接过程出错，就不要放在头文件。</strong> 一 一来看：</p><p>函数声明：显然应该放在头文件中，前面很清楚。</p><p>类定义、结构定义：用函数定义的逻辑想，似乎不能放在头文件中。但它应该放在头文件。第一，每个cpp文件应该有一个定义，在编译的时候编译器才知道怎么为对象分配空间。其次，类型定义不会在内存上分配空间。</p><p>模板函数：编译器必须在编译的时候根据函数模板实例化对应的函数，所以应该放在头文件。</p><p>内联函数：编译期间被插到调用位置，所以也要放在头文件。</p><p><strong>函数定义：不要！</strong>C++规定一个程序同签名的函数只能有一个定义。如果你把函数定义放在头文件件，并且同一个程序的多个cpp文件包含了该头文件，这样，在链接的时候会发现多个定义版本，链接报错。</p><p><strong>变量定义：不要！</strong>与上面类似，被多个文件包含的时候会出现多次定义同一个变量，链接错误。但是，static变量和extern变量可以，以及宏定义的常量，因为这些在多个文件出现并不会出错。</p><h3 id="CPP文件"><a href="#CPP文件" class="headerlink" title="CPP文件"></a>CPP文件</h3><p>.cpp文件包含模块文件和主程序文件。</p><p>主程序文件，顾名思义，就是包含main()函数的文件，是作为程序入口的存在，由它来调用模块文件实现的函数。</p><p>模块文件一般存放的是一些函数定义，因此也称为功能模块。</p><p>多文件的编译可以一键Build也可以先变异成.o再链接（这种方法会便于模块化更新）</p><h2 id="extern变量声明"><a href="#extern变量声明" class="headerlink" title="extern变量声明"></a>extern变量声明</h2><p>extern很早就遇到过，但实际用的并不多。</p><p>类似于函数的声明和定义，变量也同样可以声明和定义。</p><p>引用<a href="https://www.cnblogs.com/xiaorenwu702/p/5739845.html">cnblogs@小人物702</a>的一段话</p><blockquote><p>很多人看了可能糊涂，这里稍微说一下，其实就是<strong>变量定义</strong>和<strong>变量声明</strong>的区别，<strong>变量定义</strong>使用“数据类型+变量名称”的形式，编译器需要给他分配内存单元的；而<strong>变量声明</strong>使用“extern 变量类型+变量名称”的形式，是告诉编译器我这个变量将在其他外部c文件中定义，我这里只是在外部用它。编译器就不给他分配内存空间，而等到真正遇到变量定义的时候再给他分配内存空间。</p><p>　　由于很多人从开始学C语言就一直把<strong>定义变量</strong>叫<strong>声明变量</strong>，一开始就叫错了，所以导致现在分不清<strong>定义</strong>和<strong>声明</strong>的区别。要是还理解不了就想想<strong>函数的定义</strong>和<strong>声明</strong>，函数定义是编写函数功能实体，编译器要编译这个函数并且要分配内存空间，而函数声明并不生成函数功能实体，只是告诉编译器这是个函数，这个函数在后面将会定义实体，我这里只是提前用，编译器就会接着继续往下编译，如果子函数写在main函数之后，那么声明是必须的，如果不声明函数编译器都不知道这是个函数，编译就会报错。</p></blockquote><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h2><p>链式队列，队列的一种形式。</p><p><strong>队列</strong>，在《大话数据结构》中是这样定义的：</p><blockquote><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h2><p>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><p>1）inline定义的内联函数，函数代码被放入符号表中，在使用时进行替换（像宏一样展开），效率很高。</p><p>2）类的内联函数也是函数。编绎器在调用一个内联函数，首先会检查参数问题，保证调用正确，像对待真正函数一样，消除了隐患及局限性。</p><p>3）inline可以作为类的成员函数，刀可以使用所在类的保护成员及私有成员。</p><p>缺点：</p><p>内联函数以复制为代价，活动产函数开销</p><p>1)如果函数的代码较长，使用内联将消耗过多内存</p><p>2)如果函数体内有循环，那么执行函数代码时间比调用开销大。</p><h2 id="和-gt-的差异"><a href="#和-gt-的差异" class="headerlink" title=".和-&gt;的差异"></a>.和-&gt;的差异</h2><blockquote><p>c++中 . 和 -&gt; 主要是用法上的不同。</p><p>1、A.B则A为对象或者结构体；</p><p>2、A-&gt;B则A为指针，-&gt;是成员提取，A-&gt;B是提取A中的成员B，A只能是指向类、结构、联合的指针；</p><p>例如：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line"></span><br><span class="line">string name[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一种情况，采用指针访问 student <em>xy，则访问时需要写成 </em>xy.name=”hhhhh”；等价于xy-&gt;name=”hhhhh”。</p><p>第二种情况，采用普通成员访问 student xy，则访问时需要写成 xy.name=”hhhhh”。</p></blockquote><h2 id="指针传递和引用传递"><a href="#指针传递和引用传递" class="headerlink" title="指针传递和引用传递"></a>指针传递和引用传递</h2><p>指针传递在定义形参的时候定义为指针；使用引用传递的话需要在定义形参的时候在变量名前面加一个‘&amp;’。</p><h2 id="for-auto-i-v"><a href="#for-auto-i-v" class="headerlink" title="for(auto i : v)"></a>for(auto i : v)</h2><p>C++11新特性</p><p>范围for，相当于java的for each。v是一个可遍历的容器或流，比如vector类型，i就用来在遍历过程中获得容器里的每一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:v)</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;i;</span><br></pre></td></tr></table></figure><p>结果就是1234</p><h1 id="一些常用但是我不会的小细节"><a href="#一些常用但是我不会的小细节" class="headerlink" title="一些常用但是我不会的小细节"></a>一些常用但是我不会的小细节</h1><h2 id="string初始化"><a href="#string初始化" class="headerlink" title="string初始化"></a>string初始化</h2><h4 id="方式一-："><a href="#方式一-：" class="headerlink" title="方式一 ："></a>方式一 ：</h4><p>最简单直接, 直接赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;test01&quot;</span> ;</span><br></pre></td></tr></table></figure><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>( size_type length, <span class="type">char</span> ch );</span><br></pre></td></tr></table></figure><p>以length为长度的ch的拷贝（即length个ch）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str2</span><span class="params">( <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span> )</span></span>;  <span class="comment">//  str2 &#x27;ccccc&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="方式三-："><a href="#方式三-：" class="headerlink" title="方式三 ："></a>方式三 ：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>( <span class="type">const</span> <span class="type">char</span> *str );</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str3</span><span class="params">( <span class="string">&quot;Now is the time...&quot;</span> )</span></span>;</span><br></pre></td></tr></table></figure><h4 id="方式四："><a href="#方式四：" class="headerlink" title="方式四："></a>方式四：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>( string &amp;str, size_type index, size_type length );</span><br></pre></td></tr></table></figure><p>以index为索引开始的子串，长度为length, 或者 以从start到end的元素为初值.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str4</span><span class="params">( str3, <span class="number">11</span>, <span class="number">4</span> )</span></span>;  <span class="comment">//将str3</span></span><br></pre></td></tr></table></figure><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="string">&quot;test01&quot;</span> ;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">( <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span> )</span></span>;  <span class="comment">//  str2 &#x27;ccccc&#x27;</span></span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">( <span class="string">&quot;Now is the time...&quot;</span> )</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">( str3, <span class="number">11</span>, <span class="number">4</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210510120714786.png" alt="运行结果"></p><h1 id="引用及致谢-链接指向原文"><a href="#引用及致谢-链接指向原文" class="headerlink" title="引用及致谢(链接指向原文)"></a>引用及致谢(链接指向原文)</h1><p>union部分：<a href="https://blog.csdn.net/qq_45611002/article/details/119675452">CSDN@W Y</a></p><p>extern部分：<a href="https://www.cnblogs.com/xiaorenwu702/p/5739845.html">cnblogs@小人物702</a></p><p>多文件部分：<a href="https://blog.csdn.net/chen_z_p/article/details/105352547">CSDN@czpcalm</a></p><p>String初始化部分：<a href="https://blog.csdn.net/VariatioZbw/article/details/116592225">CSDN@zhangbw~</a></p><p>inline部分：<a href="https://blog.csdn.net/tsinfeng/article/details/5871043">CSDN@tsinfeng</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前的C++学习都是浅尝辄止，这一次直接购入《C++ Primer Plus》系统深入的学习一些C++的知识，尤其C++擅长的面向对象部分。&lt;/p&gt;
&lt;p&gt;引用表在文章末尾&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://www.lymone.cc/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="http://www.lymone.cc/tags/C/"/>
    
  </entry>
  
</feed>
